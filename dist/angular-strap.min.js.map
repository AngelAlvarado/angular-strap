{"version":3,"sources":["angular-strap.js","tooltip/tooltip.js","helpers/compiler.js","timepicker/timepicker.js","helpers/raf.js","helpers/parse-options.js","helpers/dimensions.js","helpers/debounce.js","helpers/date-parser.js","helpers/date-formatter.js","datepicker/datepicker.js","module.js"],"names":["prefixClass","undefined","templateUrl","options","cache","$templateCache","then","element","res","fetchTemplate","template","fetchPromises","module","$http","get","defaults","animation","defaultDate","data","this","compile","controller","console","controllerAs","resolve","locals","bindToController","angular","forEach","value","isString","$injector","key","transformTemplate","identity","extend","$template","when","$q","all","templateEl","Error","findElement","contentTemplate","templates","contentEl","removeAttr","html","replace","next","remove","outerHTML","link","scope","trim","contents","linkFn","invokeCtrl","children","instance","ctrl","isObject","arguments","apply","bsCompilerService","$inject","target","provider","placement","titleTemplate","trigger","keyboard","show","title","type","delay","autoClose","bsEnabled","mouseDownPreventDefault","mouseDownStopPropagation","viewport","selector","padding","TooltipFactory","$get","promise","$tooltip","$bsCompiler","split","clearTimeout","hoverState","prefixEvent","hide","isFunction","onShow","leaveAnimateCallback","$emit","destroyTipElement","onHide","_tipToHide","evt","preventDefault","triggers","nodeName","on","isTouch","toggle","enter","unbindTriggerEvents","length","$onFocusElementMouseDown","off","i","bindKeyboardEvents","tipElement","$onKeyUp","unbindKeyboardEvents","_autoCloseEventsBinded","bindAutoCloseEvents","$timeout","$body","unbindAutoCloseEvents","stopEventPropagation","event","getPosition","$element","elRect","getBoundingClientRect","rect","p","width","height","top","left","dimensions","offset","el","scroll","outerDims","isBody","document","documentElement","scrollTop","body","prop","clientWidth","innerHeight","position","actualWidth","actualHeight","marginLeft","isNaN","setOffset","using","parseInt","props","css","right","marginTop","tip","offsetHeight","getViewportAdjustedDelta","delta","offsetWidth","isVertical","arrowDelta","replaceArrow","arrowOffsetPosition","viewportDimensions","$viewport","topEdgeOffset","bottomEdgeOffset","viewportPadding","test","leftEdgeOffset","rightEdgeOffset","dimension","isHorizontal","$arrow","timeout","$isShown","tipScope","$destroy","$$phase","$options","config","$promise","$scope","$new","$rootScope","toLowerCase","$id","attr","map","parseFloat","$sce","trustAsHtml","$setEnabled","$$postDigest","id","$hide","setEnabled","isEnabled","compileData","tipContainer","init","container","bindTriggerEvents","isElement","destroy","focus","isDefined","onBeforeShow","after","parent","lastChild","display","visibility","clonedElement","addClass","safeDigest","version","prepend","$$rAF","$applyPlacement","$animate","enterAnimateCallback","_blur","onBeforeHide","blur","leave","autoPlace","autoToken","elementPosition","tipWidth","tipHeight","viewportPosition","originalPlacement","removeClass","tipPosition","getCalculatedOffset","applyPlacement","stopPropagation","directive","$root","$digest","restrict","query","querySelectorAll","isNative","tooltip","transclusion","falseValueRegExp","$eval","bsKey","dataTarget","slice","hasOwnProperty","oldValue","$observe","newValue","bsTooltip","bsShow","$watch","match","setViewport","$on","minor","requestAnimationFrame","dot","cancelAnimationFrame","$window","webkitRequestAnimationFrame","mozRequestAnimationFrame","fn","rafSupported","raf","timer","cancel","supported","$parseOptions","$values","regexp","valueName","keyName","values","index","label","displayFn","valueFn","ParseOptionsFactory","groupByFn","valuesFn","$parse","$match","isArray","displayValue","factory","offsetParent","docElement","ownerDocument","outer","window","getComputedStyle","name","extra","currentStyle","boxRect","style","curPosition","curLeft","curCSSTop","curTop","calculatePosition","curElem","curCSSLeft","curOffset","indexOf","call","offsetParentRect","offsetParentEl","offsetParentElement","func","immediate","args","context","callNow","leading","wait","trailing","year","seconds","$localeProvider","milliseconds","ParseDate","prototype","hours","noop","array","indexOfCaseInsensitive","len","str","toString","format","strict","DateParserFactory","minutes","day","month","getFullYear","getHours","getMilliseconds","getMonth","Date","getMinutes","proto","isNumeric","toDate","$dateParser","regExpMap","sss","$locale","dateFilter","mm","literalRegex","formatParts","escapedLiteralFormat","dateElements","keys","escapedFormat","isFormatStringLiteral","part","trimLiteralEscapeChars","dateRegexParts","escapeReservedSymbols","text","join","re","abstractRegex","buildDateParseRegex","setMapForFormat","buildDateAbstractRegex","buildDateParseValuesMap","Object","valuesMatch","keyIndex","valueKey","valuesFunctionMap","valueFunction","valuesRegex","exec","setFnMap","setMap","m","HH","H","hh","h","a","EEEE","EEE","DATETIME_FORMATS","SHORTDAY","dd","d","MMMM","MMM","SHORTMONTH","MM","M","DAY","yyyy","yy","y","MONTH","ss","setSeconds","s","setMinutes","setHours","setDate","setMonth","setFullYear","regex","$format","regExpForFormat","baseDate","formatRegex","formatSetMap","matches","date","getTime","timezone","newDate","fromDate","getDate","today","getDateForAttribute","substr","getTimeForAttribute","time","daylightSavingAdjust","Infinity","parse","timezoneOffsetAdjust","undo","getTimezoneOffset","getDefaultLocale","getDatetimeFormat","weekdaysShort","lang","splitTimeFormat","timeFormat","hoursFormat","minutesFormat","secondsFormat","timeSeparator","showSeconds","formatDate","service","useNative","timeType","modelTimeFormat","autoclose","minTime","maxTime","hourStep","minuteStep","secondStep","roundDisplay","iconUp","iconDown","arrowBehavior","$timepicker","timepickerFactory","viewDate","hour","startDate","meridian","coeff","selRange","select","end","start","setSelectionRange","isUndefined","collapse","selectionStart","moveStart","selectionEnd","moveEnd","focusElement","_init","parentScope","floorMinutes","floor","selectedIndex","second","getSeconds","millisecond","$dateValue","$dateFormatter","minute","$iconUp","$moveIndex","$switchMeridian","switchMeridian","isDate","$build","$isBuilt","$render","keep","$setViewValue","copy","midIndex","push","disabled","selected","$date","rows","$isDisabled","showAM","$isSelected","isAM","selectedTime","$arrowAction","$setTimeByStep","targetDate","$onMouseDown","targetEl","triggerHandler","$onKeyDown","keyCode","hoursLength","minutesLength","sepLength","lateralMove","count","selectRange","incr","isSeconds","isMeridian","secondsLength","createSelection","createTextRange","_destroy","_show","_hide","require","navigator","userAgent","isMaxValid","isValid","parsedTime","isMinValid","$setValidity","$parsers","unshift","viewValue","getTimeFormattedString","timepicker","dateParser","validateAgainstMinMaxTime","ngModel","update","$formatters","modelValue","NaN","dateType","dateFormat","modelDateFormat","dayFormat","monthFormat","yearFormat","monthTitleFormat","yearTitleFormat","strictFormat","minDate","maxDate","startView","minView","startWeek","daysOfWeekDisabled","hasToday","hasClear","iconLeft","iconRight","DatepickerFactory","$datepicker","pickerViews","views","$iconLeft","$iconRight","$hasToday","$picker","$select","$selectPane","$views","$mode","$toggleMode","$setToday","$clear","setMode","updateDisabledDates","disabledDateRanges","dateRanges","$setDisabledEl","mode","pristine","$updateSelected","built","isDisabled","steps","getUTCFullYear","getUTCMonth","UTC","getUTCDate","shiftKey","altKey","onKeyDown","datepickerViews","previousValue","normalizeDateRanges","ranges","disabledRanges","datepicker","parsedDate","getDateFormattedString","validateAgainstMinMaxDate","disabledDates","size","arrays","mod","n","arr","splice","weekDaysMin","weekDaysLabelsHtml","picker","weekDaysLabels","concat","firstDayOfMonth","firstDayOfMonthOffset","firstDate","firstDateOffset","build","days","isToday","toDateString","muted","showLabels","labels","isTodayDisabled","isSelected","getDay","months","lastDate","actualMonth","firstYear","years","actualYear","Array","setYear"],"mappings":"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","file":"angular-strap.min.js","sourcesContent":["(function(window, document, undefined) {\n'use strict';\n\n// Source: tooltip/tooltip.js\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      templateUrl: 'tooltip/tooltip.tpl.html',\n      template: '',\n      titleTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      mouseDownPreventDefault: true,\n      mouseDownStopPropagation: true,\n      viewport: {\n        selector: 'body',\n        padding: 0\n      }\n    };\n\n    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory (element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        var nodeName = element[0].nodeName.toLowerCase();\n        if (options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if (options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function (isEnabled) {\n          scope.$$postDigest(function () {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function () {\n          scope.$$postDigest(function () {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function () {\n          scope.$$postDigest(function () {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function () {\n          scope.$$postDigest(function () {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout;\n        var hoverState;\n\n        // Fetch, compile then initialize tooltip\n        var compileData;\n        var tipElement;\n        var tipContainer;\n        var tipScope;\n        promise.then(function (data) {\n          compileData = data;\n          $tooltip.init();\n        });\n\n        $tooltip.init = function () {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if (options.container === 'self') {\n            tipContainer = element;\n          } else if (angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if (options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if (options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if (options.show) {\n            scope.$$postDigest(function () {\n              if (options.trigger === 'focus') {\n                element[0].focus();\n              } else {\n                $tooltip.show();\n              }\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function () {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function () {\n            if (hoverState === 'in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function () {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\n            options.onBeforeShow($tooltip);\n          }\n          var parent;\n          var after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if (tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if (options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if (options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          if (after) {\n            after.after(tipElement);\n          } else {\n            parent.prepend(tipElement);\n          }\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\n          }\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if (tipElement) tipElement.css({visibility: 'visible'});\n\n            // Bind events\n            if (options.keyboard) {\n              if (options.trigger !== 'focus') {\n                $tooltip.focus();\n              }\n              bindKeyboardEvents();\n            }\n          });\n\n          if (options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n        };\n\n        function enterAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\n            options.onShow($tooltip);\n          }\n        }\n\n        $tooltip.leave = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function (blur) {\n\n          if (!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\n            options.onBeforeHide($tooltip);\n          }\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          if (tipElement !== null) {\n            // Support v1.2+ $animate\n            // https://github.com/angular/angular.js/issues/11713\n            if (angular.version.minor <= 2) {\n              $animate.leave(tipElement, leaveAnimateCallback);\n            } else {\n              $animate.leave(tipElement).then(leaveAnimateCallback);\n            }\n          }\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if (options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if (options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\n            options.onHide($tooltip);\n          }\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if (_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function (evt) {\n          if (evt) { evt.preventDefault(); }\n          if ($tooltip.$isShown) {\n            $tooltip.leave();\n          } else {\n            $tooltip.enter();\n          }\n        };\n\n        $tooltip.focus = function () {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function (isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function (viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function () {\n          if (!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement;\n          var autoToken = /\\s?auto?\\s?/i;\n          var autoPlace = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition();\n          var tipWidth = tipElement.prop('offsetWidth');\n          var tipHeight = tipElement.prop('offsetHeight');\n\n          // Refresh viewport position\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var viewportPosition = getPosition($tooltip.$viewport);\n\n            if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\n              placement = originalPlacement.replace('bottom', 'top');\n            } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {\n              placement = originalPlacement.replace('top', 'bottom');\n            }\n\n            if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {\n              placement = placement.replace('left', 'right');\n            } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {\n              placement = placement.replace('right', 'left');\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function (evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function (evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function (evt) {\n          if (options.mouseDownPreventDefault) { evt.preventDefault(); }\n          if (options.mouseDownStopPropagation) { evt.stopPropagation(); }\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          if ($tooltip.$isShown) {\n            element[0].blur();\n          } else {\n            element[0].focus();\n          }\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents () {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function (trigger) {\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.on(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          });\n        }\n\n        function unbindTriggerEvents () {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.off(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          }\n        }\n\n        function bindKeyboardEvents () {\n          if (options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents () {\n          if (options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents () {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents () {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation (event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition ($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0];\n          var isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          /* eslint-disable guard-for-in */\n          for (var p in elRect) { // eslint-disable-line\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n          /* eslint-enable guard-for-in */\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top});\n          }\n          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\n          var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0};\n          var outerDims = isBody ? {width: document.documentElement.clientWidth, height: $window.innerHeight} : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset (placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n            case 'right':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left + position.width\n              };\n              break;\n            case 'bottom':\n              offset = {\n                top: position.top + position.height,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n            case 'left':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left - actualWidth\n              };\n              break;\n            default:\n              offset = {\n                top: position.top - actualHeight,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n          }\n\n          if (!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if (split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n              case 'left':\n                offset.left = position.left;\n                break;\n              case 'right':\n                offset.left = position.left + position.width - actualWidth;\n                break;\n              default:\n                break;\n            }\n          } else if (split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n              case 'top':\n                offset.top = position.top - actualHeight + position.height;\n                break;\n              case 'bottom':\n                offset.top = position.top;\n                break;\n              default:\n                break;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement (offset, placement) {\n          var tip = tipElement[0];\n          var width = tip.offsetWidth;\n          var height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\n          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px',\n                right: ''\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth;\n          var actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement);\n            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\n            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\n        function getViewportAdjustedDelta (placement, position, actualWidth, actualHeight) {\n          var delta = {top: 0, left: 0};\n          if (!$tooltip.$viewport) return delta;\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\n          var viewportDimensions = getPosition($tooltip.$viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset = position.left - viewportPadding;\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow (delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement () {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if ($tooltip.$isShown && tipElement !== null) {\n            if (options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if (options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if (tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if (tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest (scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      function findElement (query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function ($window, $location, $sce, $parse, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr, transclusion) {\n\n        var tooltip;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function (newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }\n        });\n\n        attr.$observe('disabled', function (newValue) {\n          if (newValue && tooltip.$isShown) {\n            tooltip.hide();\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsTooltip) {\n          scope.$watch(attr.bsTooltip, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.title = newValue;\n            }\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }, true);\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n            if (newValue === true) {\n              tooltip.show();\n            } else {\n              tooltip.hide();\n            }\n          });\n        }\n\n        // Enabled binding support\n        if (attr.bsEnabled) {\n          scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n            if (newValue === false) {\n              tooltip.setEnabled(false);\n            } else {\n              tooltip.setEnabled(true);\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            tooltip.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: helpers/raf.js\nif (angular.version.minor < 3 && angular.version.dot < 14) {\n  angular.module('ng')\n\n  .factory('$$rAF', function ($window, $timeout) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame ||\n                                $window.webkitRequestAnimationFrame ||\n                                $window.mozRequestAnimationFrame;\n\n    var cancelAnimationFrame = $window.cancelAnimationFrame ||\n                               $window.webkitCancelAnimationFrame ||\n                               $window.mozCancelAnimationFrame ||\n                               $window.webkitCancelRequestAnimationFrame;\n\n    var rafSupported = !!requestAnimationFrame;\n    var raf = rafSupported ?\n      function (fn) {\n        var id = requestAnimationFrame(fn);\n        return function () {\n          cancelAnimationFrame(id);\n        };\n      } :\n      function (fn) {\n        var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\n        return function () {\n          $timeout.cancel(timer);\n        };\n      };\n\n    raf.supported = rafSupported;\n\n    return raf;\n\n  });\n}\n\n// Source: helpers/parse-options.js\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\n\n  .provider('$parseOptions', function () {\n\n    var defaults = this.defaults = {\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\n    };\n\n    this.$get = function ($parse, $q) {\n\n      function ParseOptionsFactory (attr, config) {\n\n        var $parseOptions = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        $parseOptions.$values = [];\n\n        // Private vars\n        var match;\n        var displayFn;\n        var valueName;\n        /* eslint-disable no-unused-vars */\n        var keyName;\n        var groupByFn;\n        /* eslint-enable no-unused-vars */\n        var valueFn;\n        var valuesFn;\n\n        $parseOptions.init = function () {\n          $parseOptions.$match = match = attr.match(options.regexp);\n          displayFn = $parse(match[2] || match[1]);\n          valueName = match[4] || match[6];\n          keyName = match[5];\n          groupByFn = $parse(match[3] || '');\n          valueFn = $parse(match[2] ? match[1] : valueName);\n          valuesFn = $parse(match[7]);\n        };\n\n        $parseOptions.valuesFn = function (scope, controller) {\n          return $q.when(valuesFn(scope, controller))\n          .then(function (values) {\n            if (!angular.isArray(values)) {\n              values = [];\n            }\n            $parseOptions.$values = values.length ? parseValues(values, scope) : [];\n            return $parseOptions.$values;\n          });\n        };\n\n        $parseOptions.displayValue = function (modelValue) {\n          var scope = {};\n          scope[valueName] = modelValue;\n          return displayFn(scope);\n        };\n\n        // Private functions\n\n        function parseValues (values, scope) {\n          return values.map(function (match, index) {\n            var locals = {};\n            var label;\n            var value;\n            locals[valueName] = match;\n            label = displayFn(scope, locals);\n            value = valueFn(scope, locals);\n            return {label: label, value: value, index: index};\n          });\n        }\n\n        $parseOptions.init();\n        return $parseOptions;\n\n      }\n\n      return ParseOptionsFactory;\n\n    };\n\n  });\n\n// Source: helpers/dimensions.js\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\n\n  .factory('dimensions', function () {\n\n    var fn = {};\n\n    /**\n     * Test the element nodeName\n     * @param element\n     * @param name\n     */\n    var nodeName = fn.nodeName = function (element, name) {\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\n    };\n\n    /**\n     * Returns the element computed style\n     * @param element\n     * @param prop\n     * @param extra\n     */\n    fn.css = function (element, prop, extra) {\n      var value;\n      if (element.currentStyle) { // IE\n        value = element.currentStyle[prop];\n      } else if (window.getComputedStyle) {\n        value = window.getComputedStyle(element)[prop];\n      } else {\n        value = element.style[prop];\n      }\n      return extra === true ? parseFloat(value) || 0 : value;\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.offset = function (element) {\n      var boxRect = element.getBoundingClientRect();\n      var docElement = element.ownerDocument;\n      return {\n        width: boxRect.width || element.offsetWidth,\n        height: boxRect.height || element.offsetHeight,\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\n      };\n    };\n\n    /**\n     * Provides set equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip\n     * @url http://api.jquery.com/offset/\n     * @param element\n     * @param options\n     * @param i\n     */\n    fn.setOffset = function (element, options, i) {\n      var curPosition;\n      var curLeft;\n      var curCSSTop;\n      var curTop;\n      var curOffset;\n      var curCSSLeft;\n      var calculatePosition;\n      var position = fn.css(element, 'position');\n      var curElem = angular.element(element);\n      var props = {};\n\n      // Set position first, in-case top/left are set even on static elem\n      if (position === 'static') {\n        element.style.position = 'relative';\n      }\n\n      curOffset = fn.offset(element);\n      curCSSTop = fn.css(element, 'top');\n      curCSSLeft = fn.css(element, 'left');\n      calculatePosition = (position === 'absolute' || position === 'fixed') &&\n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\n\n      // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n      if (calculatePosition) {\n        curPosition = fn.position(element);\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n\n      if (angular.isFunction(options)) {\n        options = options.call(element, i, curOffset);\n      }\n\n      if (options.top !== null) {\n        props.top = (options.top - curOffset.top) + curTop;\n      }\n      if (options.left !== null) {\n        props.left = (options.left - curOffset.left) + curLeft;\n      }\n\n      if ('using' in options) {\n        options.using.call(curElem, props);\n      } else {\n        curElem.css({\n          top: props.top + 'px',\n          left: props.left + 'px'\n        });\n      }\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's position function\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.position = function (element) {\n\n      var offsetParentRect = {top: 0, left: 0};\n      var offsetParentEl;\n      var offset;\n\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n      if (fn.css(element, 'position') === 'fixed') {\n\n        // We assume that getBoundingClientRect is available when computed position is fixed\n        offset = element.getBoundingClientRect();\n\n      } else {\n\n        // Get *real* offsetParentEl\n        offsetParentEl = offsetParentElement(element);\n\n        // Get correct offsets\n        offset = fn.offset(element);\n        if (!nodeName(offsetParentEl, 'html')) {\n          offsetParentRect = fn.offset(offsetParentEl);\n        }\n\n        // Add offsetParent borders\n        offsetParentRect.top += fn.css(offsetParentEl, 'borderTopWidth', true);\n        offsetParentRect.left += fn.css(offsetParentEl, 'borderLeftWidth', true);\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\n      };\n\n    };\n\n    /**\n     * Returns the closest, non-statically positioned offsetParent of a given element\n     * @required-by fn.position\n     * @param element\n     */\n    function offsetParentElement (element) {\n      var docElement = element.ownerDocument;\n      var offsetParent = element.offsetParent || docElement;\n      if (nodeName(offsetParent, '#document')) return docElement.documentElement;\n      while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docElement.documentElement;\n    }\n\n    /**\n     * Provides equivalent of jQuery's height function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/height/\n     * @param element\n     * @param outer\n     */\n    fn.height = function (element, outer) {\n      var value = element.offsetHeight;\n      if (outer) {\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\n      } else {\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\n      }\n      return value;\n    };\n\n    /**\n     * Provides equivalent of jQuery's width function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/width/\n     * @param element\n     * @param outer\n     */\n    fn.width = function (element, outer) {\n      var value = element.offsetWidth;\n      if (outer) {\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\n      } else {\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\n      }\n      return value;\n    };\n\n    return fn;\n\n  });\n\n// Source: helpers/debounce.js\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\n.factory('debounce', function ($timeout) {\n  return function (func, wait, immediate) {\n    var timeout = null;\n    return function () {\n      var context = this;\n      var args = arguments;\n      var callNow = immediate && !timeout;\n      if (timeout) {\n        $timeout.cancel(timeout);\n      }\n      timeout = $timeout(function later () {\n        timeout = null;\n        if (!immediate) {\n          func.apply(context, args);\n        }\n      }, wait, false);\n      if (callNow) {\n        func.apply(context, args);\n      }\n      return timeout;\n    };\n  };\n})\n\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\n.factory('throttle', function ($timeout) {\n  return function (func, wait, options) {\n    var timeout = null;\n    if (!options) options = {};\n    return function () {\n      var context = this;\n      var args = arguments;\n      if (!timeout) {\n        if (options.leading !== false) {\n          func.apply(context, args);\n        }\n        timeout = $timeout(function later () {\n          timeout = null;\n          if (options.trailing !== false) {\n            func.apply(context, args);\n          }\n        }, wait, false);\n      }\n    };\n  };\n});\n\n// Source: helpers/date-parser.js\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\n\n.provider('$dateParser', function ($localeProvider) {\n\n  // define a custom ParseDate object to use instead of native Date\n  // to avoid date values wrapping when setting date component values\n  function ParseDate () {\n    this.year = 1970;\n    this.month = 0;\n    this.day = 1;\n    this.hours = 0;\n    this.minutes = 0;\n    this.seconds = 0;\n    this.milliseconds = 0;\n  }\n\n  ParseDate.prototype.setMilliseconds = function (value) { this.milliseconds = value; };\n  ParseDate.prototype.setSeconds = function (value) { this.seconds = value; };\n  ParseDate.prototype.setMinutes = function (value) { this.minutes = value; };\n  ParseDate.prototype.setHours = function (value) { this.hours = value; };\n  ParseDate.prototype.getHours = function () { return this.hours; };\n  ParseDate.prototype.setDate = function (value) { this.day = value; };\n  ParseDate.prototype.setMonth = function (value) { this.month = value; };\n  ParseDate.prototype.setFullYear = function (value) { this.year = value; };\n  ParseDate.prototype.fromDate = function (value) {\n    this.year = value.getFullYear();\n    this.month = value.getMonth();\n    this.day = value.getDate();\n    this.hours = value.getHours();\n    this.minutes = value.getMinutes();\n    this.seconds = value.getSeconds();\n    this.milliseconds = value.getMilliseconds();\n    return this;\n  };\n\n  ParseDate.prototype.toDate = function () {\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\n  };\n\n  var proto = ParseDate.prototype;\n\n  function noop () {\n  }\n\n  function isNumeric (n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function indexOfCaseInsensitive (array, value) {\n    var len = array.length;\n    var str = value.toString().toLowerCase();\n    for (var i = 0; i < len; i++) {\n      if (array[i].toLowerCase() === str) { return i; }\n    }\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\n  }\n\n  var defaults = this.defaults = {\n    format: 'shortDate',\n    strict: false\n  };\n\n  this.$get = function ($locale, dateFilter) {\n\n    var DateParserFactory = function (config) {\n\n      var options = angular.extend({}, defaults, config);\n\n      var $dateParser = {};\n\n      /* eslint-disable key-spacing, quote-props */\n      var regExpMap = {\n        'sss'   : '[0-9]{3}',\n        'ss'    : '[0-5][0-9]',\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'mm'    : '[0-5][0-9]',\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'HH'    : '[01][0-9]|2[0-3]',\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\n        'hh'    : '[0][1-9]|[1][012]',\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'a'     : 'AM|PM',\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        'MM'    : '0[1-9]|1[012]',\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\n        'yy'    : '[0-9]{2}',\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'\n      };\n\n      var setFnMap = {\n        'sss'   : proto.setMilliseconds,\n        'ss'    : proto.setSeconds,\n        's'     : proto.setSeconds,\n        'mm'    : proto.setMinutes,\n        'm'     : proto.setMinutes,\n        'HH'    : proto.setHours,\n        'H'     : proto.setHours,\n        'hh'    : proto.setHours,\n        'h'     : proto.setHours,\n        'EEEE'  : noop,\n        'EEE'   : noop,\n        'dd'    : proto.setDate,\n        'd'     : proto.setDate,\n        'a'     : function (value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\n        'MMMM'  : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\n        'MMM'   : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\n        'MM'    : function (value) { return this.setMonth(1 * value - 1); },\n        'M'     : function (value) { return this.setMonth(1 * value - 1); },\n        'yyyy'  : proto.setFullYear,\n        'yy'    : function (value) { return this.setFullYear(2000 + 1 * value); },\n        'y'     : function (value) { return (1 * value <= 50 && value.length === 2) ? this.setFullYear(2000 + 1 * value) : this.setFullYear(1 * value); }\n      };\n      /* eslint-enable key-spacing, quote-props */\n\n      var regex;\n      var setMap;\n\n      $dateParser.init = function () {\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\n        regex = regExpForFormat($dateParser.$format);\n        setMap = setMapForFormat($dateParser.$format);\n      };\n\n      $dateParser.isValid = function (date) {\n        if (angular.isDate(date)) return !isNaN(date.getTime());\n        return regex.test(date);\n      };\n\n      $dateParser.parse = function (value, baseDate, format, timezone) {\n        // check for date format special names\n        if (format) format = $locale.DATETIME_FORMATS[format] || format;\n        if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\n        var formatRegex = format ? regExpForFormat(format) : regex;\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\n        var matches = formatRegex.exec(value);\n        if (!matches) return false;\n        // use custom ParseDate object to set parsed values\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\n        for (var i = 0; i < matches.length - 1; i++) {\n          if (formatSetMap[i]) formatSetMap[i].call(date, matches[i + 1]);\n        }\n        // convert back to native Date object\n        var newDate = date.toDate();\n\n        // check new native Date object for day values overflow\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\n          return false;\n        }\n\n        return newDate;\n      };\n\n      $dateParser.getDateForAttribute = function (key, value) {\n        var date;\n\n        if (value === 'today') {\n          var today = new Date();\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\n          date = new Date(value.substr(1, value.length - 2));\n        } else if (isNumeric(value)) {\n          date = new Date(parseInt(value, 10));\n        } else if (angular.isString(value) && value.length === 0) { // Reset date\n          date = key === 'minDate' ? -Infinity : +Infinity;\n        } else {\n          date = new Date(value);\n        }\n\n        return date;\n      };\n\n      $dateParser.getTimeForAttribute = function (key, value) {\n        var time;\n\n        if (value === 'now') {\n          time = new Date().setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) {\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\n        } else if (isNumeric(value)) {\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && value.length === 0) { // Reset time\n          time = key === 'minTime' ? -Infinity : +Infinity;\n        } else {\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\n        }\n\n        return time;\n      };\n\n      /* Handle switch to/from daylight saving.\n      * Hours may be non-zero on daylight saving cut-over:\n      * > 12 when midnight changeover, but then cannot generate\n      * midnight datetime, so jump to 1AM, otherwise reset.\n      * @param  date  (Date) the date to check\n      * @return  (Date) the corrected date\n      *\n      * __ copied from jquery ui datepicker __\n      */\n      $dateParser.daylightSavingAdjust = function (date) {\n        if (!date) {\n          return null;\n        }\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n        return date;\n      };\n\n      /* Correct the date for timezone offset.\n      * @param  date  (Date) the date to adjust\n      * @param  timezone  (string) the timezone to adjust for\n      * @param  undo  (boolean) to add or subtract timezone offset\n      * @return  (Date) the corrected date\n      */\n      $dateParser.timezoneOffsetAdjust = function (date, timezone, undo) {\n        if (!date) {\n          return null;\n        }\n        // Right now, only 'UTC' is supported.\n        if (timezone && timezone === 'UTC') {\n          date = new Date(date.getTime());\n          date.setMinutes(date.getMinutes() + (undo ? -1 : 1) * date.getTimezoneOffset());\n        }\n        return date;\n      };\n\n      // Private functions\n\n      function regExpForFormat (format) {\n        // `format` string can contain literal values.\n        // These need to be escaped by surrounding with\n        // single quotes (e.g. `\"h 'in the morning'\"`).\n        // In order to output a single quote, escape it - i.e.,\n        // two single quotes in a sequence (e.g. `\"h 'o''clock'\"`).\n\n        var re = buildDateAbstractRegex(format);\n        return buildDateParseRegex(re);\n      }\n\n      function buildDateAbstractRegex (format) {\n        var escapedFormat = escapeReservedSymbols(format);\n        var escapedLiteralFormat = escapedFormat.replace(/''/g, '\\\\\\'');\n        var literalRegex = /('(?:\\\\'|.)*?')/;\n        var formatParts = escapedLiteralFormat.split(literalRegex);\n        var dateElements = Object.keys(regExpMap);\n        var dateRegexParts = [];\n\n        angular.forEach(formatParts, function (part) {\n          if (isFormatStringLiteral(part)) {\n            part = trimLiteralEscapeChars(part);\n          } else {\n            // Abstract replaces to avoid collisions\n            for (var i = 0; i < dateElements.length; i++) {\n              part = part.split(dateElements[i]).join('${' + i + '}');\n            }\n          }\n          dateRegexParts.push(part);\n        });\n\n        return dateRegexParts.join('');\n      }\n\n      function escapeReservedSymbols (text) {\n        return text.replace(/\\\\/g, '[\\\\\\\\]')\n                   .replace(/-/g, '[-]')\n                   .replace(/\\./g, '[.]')\n                   .replace(/\\*/g, '[*]')\n                   .replace(/\\+/g, '[+]')\n                   .replace(/\\?/g, '[?]')\n                   .replace(/\\$/g, '[$]')\n                   .replace(/\\^/g, '[^]')\n                   .replace(/\\//g, '[/]')\n                   .replace(/\\\\s/g, '[\\\\s]');\n      }\n\n      function isFormatStringLiteral (text) {\n        return /^'.*'$/.test(text);\n      }\n\n      function trimLiteralEscapeChars (text) {\n        return text.replace(/^'(.*)'$/, '$1');\n      }\n\n      function buildDateParseRegex (abstractRegex) {\n        var dateElements = Object.keys(regExpMap);\n        var re = abstractRegex;\n\n        // Replace abstracted values\n        for (var i = 0; i < dateElements.length; i++) {\n          re = re.split('${' + i + '}').join('(' + regExpMap[dateElements[i]] + ')');\n        }\n\n        return new RegExp('^' + re + '$', ['i']);\n      }\n\n      function setMapForFormat (format) {\n        var re = buildDateAbstractRegex(format);\n        return buildDateParseValuesMap(re);\n      }\n\n      function buildDateParseValuesMap (abstractRegex) {\n        var dateElements = Object.keys(regExpMap);\n        var valuesRegex = new RegExp('\\\\${(\\\\d+)}', 'g');\n        var valuesMatch;\n        var keyIndex;\n        var valueKey;\n        var valueFunction;\n        var valuesFunctionMap = [];\n\n        /* eslint-disable no-cond-assign */\n        while ((valuesMatch = valuesRegex.exec(abstractRegex)) !== null) {\n          keyIndex = valuesMatch[1];\n          valueKey = dateElements[keyIndex];\n          valueFunction = setFnMap[valueKey];\n\n          valuesFunctionMap.push(valueFunction);\n        }\n\n        return valuesFunctionMap;\n      }\n\n      $dateParser.init();\n      return $dateParser;\n\n    };\n\n    return DateParserFactory;\n\n  };\n\n});\n\n// Source: helpers/date-formatter.js\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\n\n  .service('$dateFormatter', function ($locale, dateFilter) {\n\n    // The unused `lang` arguments are on purpose. The default implementation does not\n    // use them and it always uses the locale loaded into the `$locale` service.\n    // Custom implementations might use it, thus allowing different directives to\n    // have different languages.\n\n    this.getDefaultLocale = function () {\n      return $locale.id;\n    };\n\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\n    // Return either the corresponding date format or the given date format.\n    this.getDatetimeFormat = function (format, lang) {\n      return $locale.DATETIME_FORMATS[format] || format;\n    };\n\n    this.weekdaysShort = function (lang) {\n      return $locale.DATETIME_FORMATS.SHORTDAY;\n    };\n\n    function splitTimeFormat (format) {\n      return /(h+)([:\\.])?(m+)([:\\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);\n    }\n\n    // h:mm a => h\n    this.hoursFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[0];\n    };\n\n    // h:mm a => mm\n    this.minutesFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[2];\n    };\n\n    // h:mm:ss a => ss\n    this.secondsFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => :\n    this.timeSeparator = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[1];\n    };\n\n    // h:mm:ss a => true, h:mm a => false\n    this.showSeconds = function (timeFormat) {\n      return !!splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => true, H.mm => false\n    this.showAM = function (timeFormat) {\n      return !!splitTimeFormat(timeFormat)[5];\n    };\n\n    this.formatDate = function (date, format, lang, timezone) {\n      return dateFilter(date, format, timezone);\n    };\n\n  });\n\n// Source: helpers/compiler.js\n// NOTICE: This file was forked from the angular-material project (github.com/angular/material)\n// MIT Licensed - Copyright (c) 2014-2015 Google, Inc. http://angularjs.org\n\nangular.module('mgcrea.ngStrap.core', [])\n  .service('$bsCompiler', bsCompilerService);\n\nfunction bsCompilerService ($q, $http, $injector, $compile, $controller, $templateCache) {\n\n  /*\n   * @ngdoc service\n   * @name $bsCompiler\n   * @module material.core\n   * @description\n   * The $bsCompiler service is an abstraction of angular's compiler, that allows the developer\n   * to easily compile an element with a templateUrl, controller, and locals.\n   *\n   * @usage\n   * <hljs lang=\"js\">\n   * $bsCompiler.compile({\n   *   templateUrl: 'modal.html',\n   *   controller: 'ModalCtrl',\n   *   locals: {\n   *     modal: myModalInstance;\n   *   }\n   * }).then(function(compileData) {\n   *   compileData.element; // modal.html's template in an element\n   *   compileData.link(myScope); //attach controller & scope to element\n   * });\n   * </hljs>\n   */\n\n   /*\n    * @ngdoc method\n    * @name $bsCompiler#compile\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\n    * locals, and scope.\n    * @param {object} options An options object, with the following properties:\n    *\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\n    *      newly created scope or the name of a registered controller if passed as a string.\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\n    *      published to scope under the `controllerAs` name.\n    *    - `template` - `{string=}` An html template as a string.\n    *    - `templateUrl` - `{string=}` A path to an html template.\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\n    *      it is loaded. It will be given the template string as a parameter, and should\n    *      return a a new string representing the transformed template.\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\n    *      instantiated `compile()` will fail..\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\n    *        Otherwise if function, then it is injected and the return value is treated as the\n    *        dependency. If the result is a promise, it is resolved before its value is\n    *        injected into the controller.\n    *\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\n    * `compileData` has the following properties:\n    *\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\n    *     the element and instantiate the provided controller (if given).\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\n    */\n  this.compile = function (options) {\n\n    if (options.template && /\\.html$/.test(options.template)) {\n      console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');\n      options.templateUrl = options.template;\n      options.template = '';\n    }\n\n    var templateUrl = options.templateUrl;\n    var template = options.template || '';\n    var controller = options.controller;\n    var controllerAs = options.controllerAs;\n    var resolve = options.resolve || {};\n    var locals = options.locals || {};\n    var transformTemplate = options.transformTemplate || angular.identity;\n    var bindToController = options.bindToController;\n\n    // Take resolve values and invoke them.\n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\n    angular.forEach(resolve, function (value, key) {\n      if (angular.isString(value)) {\n        resolve[key] = $injector.get(value);\n      } else {\n        resolve[key] = $injector.invoke(value);\n      }\n    });\n    // Add the locals, which are just straight values to inject\n    // eg locals: { three: 3 }, will inject three into the controller\n    angular.extend(resolve, locals);\n\n    if (template) {\n      resolve.$template = $q.when(template);\n    } else if (templateUrl) {\n      resolve.$template = fetchTemplate(templateUrl);\n    } else {\n      throw new Error('Missing `template` / `templateUrl` option.');\n    }\n\n    if (options.titleTemplate) {\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.titleTemplate)])\n        .then(function (templates) {\n          var templateEl = angular.element(templates[0]);\n          findElement('[ng-bind=\"title\"]', templateEl[0])\n            .removeAttr('ng-bind')\n            .html(templates[1]);\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    if (options.contentTemplate) {\n      // TODO(mgcrea): deprecate?\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.contentTemplate)])\n        .then(function (templates) {\n          var templateEl = angular.element(templates[0]);\n          var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0])\n            .removeAttr('ng-bind')\n            .html(templates[1]);\n          // Drop the default footer as you probably don't want it if you use a custom contentTemplate\n          if (!options.templateUrl) contentEl.next().remove();\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    // Wait for all the resolves to finish if they are promises\n    return $q.all(resolve).then(function (locals) {\n\n      var template = transformTemplate(locals.$template);\n      if (options.html) {\n        template = template.replace(/ng-bind=\"/ig, 'ng-bind-html=\"');\n      }\n      // var element = options.element || angular.element('<div>').html(template.trim()).contents();\n      var element = angular.element('<div>').html(template.trim()).contents();\n      var linkFn = $compile(element);\n\n      // Return a linking function that can be used later when the element is ready\n      return {\n        locals: locals,\n        element: element,\n        link: function link (scope) {\n          locals.$scope = scope;\n\n          // Instantiate controller if it exists, because we have scope\n          if (controller) {\n            var invokeCtrl = $controller(controller, locals, true);\n            if (bindToController) {\n              angular.extend(invokeCtrl.instance, locals);\n            }\n            // Support angular@~1.2 invokeCtrl\n            var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();\n            // See angular-route source for this logic\n            element.data('$ngControllerController', ctrl);\n            element.children().data('$ngControllerController', ctrl);\n\n            if (controllerAs) {\n              scope[controllerAs] = ctrl;\n            }\n          }\n\n          return linkFn.apply(null, arguments);\n        }\n      };\n    });\n\n  };\n\n  function findElement (query, element) {\n    return angular.element((element || document).querySelectorAll(query));\n  }\n\n  var fetchPromises = {};\n  function fetchTemplate (template) {\n    if (fetchPromises[template]) return fetchPromises[template];\n    return (fetchPromises[template] = $http.get(template, {cache: $templateCache})\n      .then(function (res) {\n        return res.data;\n      }));\n  }\n\n}\n\n// Source: timepicker/timepicker.js\nangular.module('mgcrea.ngStrap.timepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip'])\n\n  .provider('$timepicker', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      defaultDate: 'auto',\n      // uncommenting the following line will break backwards compatability\n      // prefixEvent: 'timepicker',\n      prefixClass: 'timepicker',\n      placement: 'bottom-left',\n      templateUrl: 'timepicker/timepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: true,\n      timeType: 'date',\n      timeFormat: 'shortTime',\n      timezone: null,\n      modelTimeFormat: null,\n      autoclose: false,\n      minTime: -Infinity,\n      maxTime: +Infinity,\n      length: 5,\n      hourStep: 1,\n      minuteStep: 5,\n      secondStep: 5,\n      roundDisplay: false,\n      iconUp: 'glyphicon glyphicon-chevron-up',\n      iconDown: 'glyphicon glyphicon-chevron-down',\n      arrowBehavior: 'pager'\n    };\n\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if (!defaults.lang) {\n        defaults.lang = $dateFormatter.getDefaultLocale();\n      }\n\n      function timepickerFactory (element, controller, config) {\n\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $timepicker.$options;\n        var scope = $timepicker.$scope;\n\n        var lang = options.lang;\n        var formatDate = function (date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        function floorMinutes (time) {\n          // coeff used to floor current time to nearest minuteStep interval\n          var coeff = 1000 * 60 * options.minuteStep;\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\n        }\n\n        // View vars\n\n        var selectedIndex = 0;\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\n        var startDate = controller.$dateValue || defaultDate;\n        var viewDate = {\n          hour: startDate.getHours(),\n          meridian: startDate.getHours() < 12,\n          minute: startDate.getMinutes(),\n          second: startDate.getSeconds(),\n          millisecond: startDate.getMilliseconds()\n        };\n\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\n\n        var hoursFormat = $dateFormatter.hoursFormat(format);\n        var timeSeparator = $dateFormatter.timeSeparator(format);\n        var minutesFormat = $dateFormatter.minutesFormat(format);\n        var secondsFormat = $dateFormatter.secondsFormat(format);\n        var showSeconds = $dateFormatter.showSeconds(format);\n        var showAM = $dateFormatter.showAM(format);\n\n        scope.$iconUp = options.iconUp;\n        scope.$iconDown = options.iconDown;\n\n        // Scope methods\n\n        scope.$select = function (date, index) {\n          $timepicker.select(date, index);\n        };\n        scope.$moveIndex = function (value, index) {\n          $timepicker.$moveIndex(value, index);\n        };\n        scope.$switchMeridian = function (date) {\n          $timepicker.switchMeridian(date);\n        };\n\n        // Public methods\n\n        $timepicker.update = function (date) {\n          // console.warn('$timepicker.update() newValue=%o', date);\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\n            $timepicker.$date = date;\n            angular.extend(viewDate, {\n              hour: date.getHours(),\n              minute: date.getMinutes(),\n              second: date.getSeconds(),\n              millisecond: date.getMilliseconds()\n            });\n            $timepicker.$build();\n          } else if (!$timepicker.$isBuilt) {\n            $timepicker.$build();\n          }\n        };\n\n        $timepicker.select = function (date, index, keep) {\n          // console.warn('$timepicker.select', date, scope.$mode);\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n            controller.$dateValue = options.defaultDate === 'today' ? new Date() : new Date(1970, 0, 1);\n          }\n\n          if (!angular.isDate(date)) date = new Date(date);\n          if (index === 0) controller.$dateValue.setHours(date.getHours());\n          else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes());\n          else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n          if (options.autoclose && !keep) {\n            $timeout(function () {\n              $timepicker.hide(true);\n            });\n          }\n        };\n\n        $timepicker.switchMeridian = function (date) {\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n            return;\n          }\n          var hours = (date || controller.$dateValue).getHours();\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n        };\n\n        // Protected methods\n\n        $timepicker.$build = function () {\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\n          var i;\n          var midIndex = scope.midIndex = parseInt(options.length / 2, 10);\n          var hours = [];\n          var hour;\n          for (i = 0; i < options.length; i++) {\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\n            hours.push({\n              date: hour,\n              label: formatDate(hour, hoursFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),\n              disabled: $timepicker.$isDisabled(hour, 0)\n            });\n          }\n          var minutes = [];\n          var minute;\n          for (i = 0; i < options.length; i++) {\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\n            minutes.push({\n              date: minute,\n              label: formatDate(minute, minutesFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),\n              disabled: $timepicker.$isDisabled(minute, 1)\n            });\n          }\n          var seconds = [];\n          var second;\n          for (i = 0; i < options.length; i++) {\n            second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);\n            seconds.push({\n              date: second,\n              label: formatDate(second, secondsFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(second, 2),\n              disabled: $timepicker.$isDisabled(second, 2)\n            });\n          }\n\n          var rows = [];\n          for (i = 0; i < options.length; i++) {\n            if (showSeconds) {\n              rows.push([hours[i], minutes[i], seconds[i]]);\n            } else {\n              rows.push([hours[i], minutes[i]]);\n            }\n          }\n          scope.rows = rows;\n          scope.showSeconds = showSeconds;\n          scope.showAM = showAM;\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\n          scope.timeSeparator = timeSeparator;\n          $timepicker.$isBuilt = true;\n        };\n\n        $timepicker.$isSelected = function (date, index) {\n          if (!$timepicker.$date) return false;\n          else if (index === 0) {\n            return date.getHours() === $timepicker.$date.getHours();\n          } else if (index === 1) {\n            return date.getMinutes() === $timepicker.$date.getMinutes();\n          } else if (index === 2) {\n            return date.getSeconds() === $timepicker.$date.getSeconds();\n          }\n        };\n\n        $timepicker.$isDisabled = function (date, index) {\n          var selectedTime;\n          if (index === 0) {\n            selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;\n          } else if (index === 1) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;\n          } else if (index === 2) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;\n          }\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\n        };\n\n        scope.$arrowAction = function (value, index) {\n          if (options.arrowBehavior === 'picker') {\n            $timepicker.$setTimeByStep(value, index);\n          } else {\n            $timepicker.$moveIndex(value, index);\n          }\n        };\n\n        $timepicker.$setTimeByStep = function (value, index) {\n          var newDate = new Date($timepicker.$date || startDate);\n          var hours = newDate.getHours();\n          var minutes = newDate.getMinutes();\n          var seconds = newDate.getSeconds();\n          if (index === 0) {\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\n          } else if (index === 1) {\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\n          } else if (index === 2) {\n            newDate.setSeconds(seconds - (parseInt(options.secondStep, 10) * value));\n          }\n          $timepicker.select(newDate, index, true);\n        };\n\n        $timepicker.$moveIndex = function (value, index) {\n          var targetDate;\n          if (index === 0) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute, viewDate.second);\n            angular.extend(viewDate, {\n              hour: targetDate.getHours()\n            });\n          } else if (index === 1) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep), viewDate.second);\n            angular.extend(viewDate, {\n              minute: targetDate.getMinutes()\n            });\n          } else if (index === 2) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + (value * options.length * options.secondStep));\n            angular.extend(viewDate, {\n              second: targetDate.getSeconds()\n            });\n          }\n          $timepicker.$build();\n        };\n\n        $timepicker.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $timepicker.$onKeyDown = function (evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Close on enter\n          if (evt.keyCode === 13) {\n            $timepicker.hide(true);\n            return;\n          }\n\n          // Navigate with keyboard\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours();\n          var hoursLength = formatDate(newDate, hoursFormat).length;\n          var minutes = newDate.getMinutes();\n          var minutesLength = formatDate(newDate, minutesFormat).length;\n          var seconds = newDate.getSeconds();\n          var secondsLength = formatDate(newDate, secondsFormat).length;\n          var sepLength = 1;\n          var lateralMove = /(37|39)/.test(evt.keyCode);\n          var count = 2 + showSeconds * 1 + showAM * 1;\n\n          // Navigate indexes (left, right)\n          if (lateralMove) {\n            if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\n            else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\n          }\n\n          // Update values (up, down)\n          var selectRange = [0, hoursLength];\n          var incr = 0;\n          if (evt.keyCode === 38) incr = -1;\n          if (evt.keyCode === 40) incr = +1;\n          var isSeconds = selectedIndex === 2 && showSeconds;\n          var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;\n          if (selectedIndex === 0) {\n            newDate.setHours(hours + incr * parseInt(options.hourStep, 10));\n            // re-calculate hours length because we have changed hours value\n            hoursLength = formatDate(newDate, hoursFormat).length;\n            selectRange = [0, hoursLength];\n          } else if (selectedIndex === 1) {\n            newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));\n            // re-calculate minutes length because we have changes minutes value\n            minutesLength = formatDate(newDate, minutesFormat).length;\n            selectRange = [hoursLength + sepLength, minutesLength];\n          } else if (isSeconds) {\n            newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));\n            // re-calculate seconds length because we have changes seconds value\n            secondsLength = formatDate(newDate, secondsFormat).length;\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength, secondsLength];\n          } else if (isMeridian) {\n            if (!lateralMove) $timepicker.switchMeridian();\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2];\n          }\n          $timepicker.select(newDate, selectedIndex, true);\n          createSelection(selectRange[0], selectRange[1]);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function createSelection (start, length) {\n          var end = start + length;\n          if (element[0].createTextRange) {\n            var selRange = element[0].createTextRange();\n            selRange.collapse(true);\n            selRange.moveStart('character', start);\n            selRange.moveEnd('character', end);\n            selRange.select();\n          } else if (element[0].setSelectionRange) {\n            element[0].setSelectionRange(start, end);\n          } else if (angular.isUndefined(element[0].selectionStart)) {\n            element[0].selectionStart = start;\n            element[0].selectionEnd = end;\n          }\n        }\n\n        function focusElement () {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $timepicker.init;\n        $timepicker.init = function () {\n          if (isNative && options.useNative) {\n            element.prop('type', 'time');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if (isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $timepicker.destroy;\n        $timepicker.destroy = function () {\n          if (isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $timepicker.show;\n        $timepicker.show = function () {\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            if ($timepicker.$element) $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n            if (options.keyboard) {\n              if (element) element.on('keydown', $timepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $timepicker.hide;\n        $timepicker.hide = function (blur) {\n          if (!$timepicker.$isShown) return;\n          if ($timepicker.$element) $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n          if (options.keyboard) {\n            if (element) element.off('keydown', $timepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $timepicker;\n\n      }\n\n      timepickerFactory.defaults = defaults;\n      return timepickerFactory;\n\n    };\n\n  })\n\n\n  .directive('bsTimepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\n\n    var defaults = $timepicker.defaults;\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink (scope, element, attr, controller) {\n\n        // Directive options\n        var options = {\n          scope: scope\n        };\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent', 'defaultDate'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'roundDisplay'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // Initialize timepicker\n        if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\n        var timepicker = $timepicker(element, controller, options);\n        options = timepicker.$options;\n\n        var lang = options.lang;\n        var formatDate = function (date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!timepicker || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\n            if (newValue === true) {\n              timepicker.show();\n            } else {\n              timepicker.hide();\n            }\n          });\n        }\n\n        // Initialize parser\n        var dateParser = $dateParser({\n          format: options.timeFormat,\n          lang: lang\n        });\n\n        // Observe attributes for changes\n        angular.forEach(['minTime', 'maxTime'], function (key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          if (angular.isDefined(attr[key])) {\n            attr.$observe(key, function (newValue) {\n              timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\n              if (!isNaN(timepicker.$options[key])) timepicker.$build();\n              validateAgainstMinMaxTime(controller.$dateValue);\n            });\n          }\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\n          timepicker.update(controller.$dateValue);\n        }, true);\n\n        function validateAgainstMinMaxTime (parsedTime) {\n          if (!angular.isDate(parsedTime)) return;\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if (!isValid) {\n            return;\n          }\n          controller.$dateValue = parsedTime;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function (viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if (!viewValue) {\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            controller.$setValidity('date', true);\n            return null;\n          }\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\n          if (!parsedTime || isNaN(parsedTime.getTime())) {\n            controller.$setValidity('date', false);\n            // Return undefined, causes ngModelController to\n            // invalidate model value\n            return undefined;\n          }\n          validateAgainstMinMaxTime(parsedTime);\n\n          if (options.timeType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\n            return formatDate(date, options.modelTimeFormat || options.timeFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if (options.timeType === 'number') {\n            return date.getTime();\n          } else if (options.timeType === 'unix') {\n            return date.getTime() / 1000;\n          } else if (options.timeType === 'iso') {\n            return date.toISOString();\n          }\n          return new Date(date);\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if (angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if (angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if (options.timeType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\n          } else if (options.timeType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getTimeFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function () {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getTimeFormattedString());\n        };\n\n        function getTimeFormattedString () {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (timepicker) timepicker.destroy();\n          options = null;\n          timepicker = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: datepicker/datepicker.js\nangular.module('mgcrea.ngStrap.datepicker', [\n  'mgcrea.ngStrap.helpers.dateParser',\n  'mgcrea.ngStrap.helpers.dateFormatter',\n  'mgcrea.ngStrap.tooltip'])\n\n  .provider('$datepicker', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      // Uncommenting the following line will break backwards compatability\n      // prefixEvent: 'datepicker',\n      prefixClass: 'datepicker',\n      placement: 'bottom-left',\n      templateUrl: 'datepicker/datepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: false,\n      dateType: 'date',\n      dateFormat: 'shortDate',\n      timezone: null,\n      modelDateFormat: null,\n      dayFormat: 'dd',\n      monthFormat: 'MMM',\n      yearFormat: 'yyyy',\n      monthTitleFormat: 'MMMM yyyy',\n      yearTitleFormat: 'yyyy',\n      strictFormat: false,\n      autoclose: false,\n      minDate: -Infinity,\n      maxDate: +Infinity,\n      startView: 0,\n      minView: 0,\n      startWeek: 0,\n      daysOfWeekDisabled: '',\n      hasToday: false,\n      hasClear: false,\n      iconLeft: 'glyphicon glyphicon-chevron-left',\n      iconRight: 'glyphicon glyphicon-chevron-right'\n    };\n\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if (!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n      function DatepickerFactory (element, controller, config) {\n\n        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $datepicker.$options;\n        var scope = $datepicker.$scope;\n        if (options.startView) options.startView -= options.minView;\n\n        // View vars\n\n        var pickerViews = datepickerViews($datepicker);\n        $datepicker.$views = pickerViews.views;\n        var viewDate = pickerViews.viewDate;\n        scope.$mode = options.startView;\n        scope.$iconLeft = options.iconLeft;\n        scope.$iconRight = options.iconRight;\n        scope.$hasToday = options.hasToday;\n        scope.$hasClear = options.hasClear;\n        var $picker = $datepicker.$views[scope.$mode];\n\n        // Scope methods\n\n        scope.$select = function (date, disabled) {\n          if (disabled) return;\n          $datepicker.select(date);\n        };\n        scope.$selectPane = function (value) {\n          $datepicker.$selectPane(value);\n        };\n        scope.$toggleMode = function () {\n          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\n        };\n        scope.$setToday = function () {\n          if (options.autoclose) {\n            $datepicker.setMode(0);\n            $datepicker.select(new Date());\n          } else {\n            $datepicker.select(new Date(), true);\n          }\n        };\n        scope.$clear = function () {\n          if (options.autoclose) {\n            $datepicker.setMode(0);\n            $datepicker.select(null);\n          } else {\n            $datepicker.select(null, true);\n          }\n        };\n\n        // Public methods\n\n        $datepicker.update = function (date) {\n          // console.warn('$datepicker.update() newValue=%o', date);\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\n            $datepicker.$date = date;\n            $picker.update.call($picker, date);\n          }\n          // Build only if pristine\n          $datepicker.$build(true);\n        };\n\n        $datepicker.updateDisabledDates = function (dateRanges) {\n          options.disabledDateRanges = dateRanges;\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\n          }\n        };\n\n        $datepicker.select = function (date, keep) {\n          // console.warn('$datepicker.select', date, scope.$mode);\n          if (angular.isDate(date)) {\n            if (!angular.isDate(controller.$dateValue) || isNaN(controller.$dateValue.getTime())) {\n              controller.$dateValue = new Date(date);\n            }\n          } else {\n            controller.$dateValue = null;\n          }\n          if (!scope.$mode || keep) {\n            controller.$setViewValue(angular.copy(date));\n            controller.$render();\n            if (options.autoclose && !keep) {\n              $timeout(function () { $datepicker.hide(true); });\n            }\n          } else {\n            angular.extend(viewDate, {year: date.getFullYear(), month: date.getMonth(), date: date.getDate()});\n            $datepicker.setMode(scope.$mode - 1);\n            $datepicker.$build();\n          }\n        };\n\n        $datepicker.setMode = function (mode) {\n          // console.warn('$datepicker.setMode', mode);\n          scope.$mode = mode;\n          $picker = $datepicker.$views[scope.$mode];\n          $datepicker.$build();\n        };\n\n        // Protected methods\n\n        $datepicker.$build = function (pristine) {\n          // console.warn('$datepicker.$build() viewDate=%o', viewDate);\n          if (pristine === true && $picker.built) return;\n          if (pristine === false && !$picker.built) return;\n          $picker.build.call($picker);\n        };\n\n        $datepicker.$updateSelected = function () {\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], updateSelected);\n          }\n        };\n\n        $datepicker.$isSelected = function (date) {\n          return $picker.isSelected(date);\n        };\n\n        $datepicker.$setDisabledEl = function (el) {\n          el.disabled = $picker.isDisabled(el.date);\n        };\n\n        $datepicker.$selectPane = function (value) {\n          var steps = $picker.steps;\n          // set targetDate to first day of month to avoid problems with\n          // date values rollover. This assumes the viewDate does not\n          // depend on the day of the month\n          var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\n          angular.extend(viewDate, {year: targetDate.getUTCFullYear(), month: targetDate.getUTCMonth(), date: targetDate.getUTCDate()});\n          $datepicker.$build();\n        };\n\n        $datepicker.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $datepicker.$onKeyDown = function (evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          if (evt.keyCode === 13) {\n            if (!scope.$mode) {\n              $datepicker.hide(true);\n            } else {\n              scope.$apply(function () { $datepicker.setMode(scope.$mode - 1); });\n            }\n            return;\n          }\n\n          // Navigate with keyboard\n          $picker.onKeyDown(evt);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function updateSelected (el) {\n          el.selected = $datepicker.$isSelected(el.date);\n        }\n\n        function focusElement () {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $datepicker.init;\n        $datepicker.init = function () {\n          if (isNative && options.useNative) {\n            element.prop('type', 'date');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if (isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $datepicker.destroy;\n        $datepicker.destroy = function () {\n          if (isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $datepicker.show;\n        $datepicker.show = function () {\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            // if $datepicker is no longer showing, don't setup events\n            if (!$datepicker.$isShown) return;\n            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n            if (options.keyboard) {\n              element.on('keydown', $datepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $datepicker.hide;\n        $datepicker.hide = function (blur) {\n          if (!$datepicker.$isShown) return;\n          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n          if (options.keyboard) {\n            element.off('keydown', $datepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $datepicker;\n\n      }\n\n      DatepickerFactory.defaults = defaults;\n      return DatepickerFactory;\n\n    };\n\n  })\n\n  .directive('bsDatepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\n\n    // var defaults = $datepicker.defaults;\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink (scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent', 'hasToday', 'hasClear'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'hasToday', 'hasClear'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // Initialize datepicker\n        var datepicker = $datepicker(element, controller, options);\n        options = datepicker.$options;\n        // Set expected iOS format\n        if (isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\n\n        var lang = options.lang;\n\n        var formatDate = function (date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!datepicker || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\n            if (newValue === true) {\n              datepicker.show();\n            } else {\n              datepicker.hide();\n            }\n          });\n        }\n\n        // Observe attributes for changes\n        angular.forEach(['minDate', 'maxDate'], function (key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          if (angular.isDefined(attr[key])) {\n            attr.$observe(key, function (newValue) {\n              // console.warn('attr.$observe(%s)=%o', key, newValue);\n              datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\n              // Build only if dirty\n              if (!isNaN(datepicker.$options[key])) datepicker.$build(false);\n              validateAgainstMinMaxDate(controller.$dateValue);\n            });\n          }\n        });\n\n        // Observe date format\n        if (angular.isDefined(attr.dateFormat)) {\n          attr.$observe('dateFormat', function (newValue) {\n            datepicker.$options.dateFormat = newValue;\n          });\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          datepicker.update(controller.$dateValue);\n        }, true);\n\n        // Normalize undefined/null/empty array,\n        // so that we don't treat changing from undefined->null as a change.\n        function normalizeDateRanges (ranges) {\n          if (!ranges || !ranges.length) return null;\n          return ranges;\n        }\n\n        if (angular.isDefined(attr.disabledDates)) {\n          scope.$watch(attr.disabledDates, function (disabledRanges, previousValue) {\n            disabledRanges = normalizeDateRanges(disabledRanges);\n            previousValue = normalizeDateRanges(previousValue);\n\n            if (disabledRanges) {\n              datepicker.updateDisabledDates(disabledRanges);\n            }\n          });\n        }\n\n        function validateAgainstMinMaxDate (parsedDate) {\n          if (!angular.isDate(parsedDate)) return;\n          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\n          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if (isValid) controller.$dateValue = parsedDate;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function (viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if (!viewValue) {\n            controller.$setValidity('date', true);\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            return null;\n          }\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\n            controller.$setValidity('date', false);\n            // return undefined, causes ngModelController to\n            // invalidate model value\n            return;\n          }\n          validateAgainstMinMaxDate(parsedDate);\n\n          if (options.dateType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if (options.dateType === 'number') {\n            return date.getTime();\n          } else if (options.dateType === 'unix') {\n            return date.getTime() / 1000;\n          } else if (options.dateType === 'iso') {\n            return date.toISOString();\n          }\n          return new Date(date);\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if (angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if (angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if (options.dateType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\n          } else if (options.dateType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if (isNaN(date.getTime())) {\n          //   var today = new Date();\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\n          // }\n          // do not adjust date if timezone is UTC\n          if (options.timezone === 'UTC') {\n            controller.$dateValue = date;\n          } else {\n            controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          }\n          return getDateFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function () {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getDateFormattedString());\n        };\n\n        function getDateFormattedString () {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (datepicker) datepicker.destroy();\n          options = null;\n          datepicker = null;\n        });\n\n      }\n    };\n\n  })\n\n  .provider('datepickerViews', function () {\n\n    // var defaults = this.defaults = {\n    //   dayFormat: 'dd',\n    //   daySplit: 7\n    // };\n\n    // Split array into smaller arrays\n    function split (arr, size) {\n      var arrays = [];\n      while (arr.length > 0) {\n        arrays.push(arr.splice(0, size));\n      }\n      return arrays;\n    }\n\n    // Modulus operator\n    function mod (n, m) {\n      return ((n % m) + m) % m;\n    }\n\n    this.$get = function ($dateFormatter, $dateParser, $sce) {\n\n      return function (picker) {\n\n        var scope = picker.$scope;\n        var options = picker.$options;\n\n        var lang = options.lang;\n        var formatDate = function (date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        var weekDaysMin = $dateFormatter.weekdaysShort(lang);\n        var weekDaysLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\n        var weekDaysLabelsHtml = $sce.trustAsHtml('<th class=\"dow text-center\">' + weekDaysLabels.join('</th><th class=\"dow text-center\">') + '</th>');\n\n        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\n        var viewDate = {year: startDate.getFullYear(), month: startDate.getMonth(), date: startDate.getDate()};\n\n        var views = [{\n          format: options.dayFormat,\n          split: 7,\n          steps: {month: 1},\n          update: function (date, force) {\n            if (!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getDate() !== viewDate.date || date.getDate() === 1) {\n                // chaging picker current month will cause viewDate.date to be set to first day of the month,\n                // in $datepicker.$selectPane, so picker would not update selected day display if\n                // user picks first day of the new month.\n                // As a workaround, we are always forcing update when picked date is first day of month.\n              viewDate.date = picker.$date.getDate();\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1);\n            var firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\n            var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5);\n            var firstDateOffset = firstDate.getTimezoneOffset();\n            var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\n              // Handle daylight time switch\n            if (firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\n            var days = [];\n            var day;\n            for (var i = 0; i < 42; i++) { // < 7 * 6\n              day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\n              days.push({date: day, isToday: day.toDateString() === today, label: formatDate(day, this.format), selected: picker.$date && this.isSelected(day), muted: day.getMonth() !== viewDate.month, disabled: this.isDisabled(day)});\n            }\n            scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\n            scope.showLabels = true;\n            scope.labels = weekDaysLabelsHtml;\n            scope.rows = split(days, this.split);\n            scope.isTodayDisabled = this.isDisabled(new Date());\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth() && date.getDate() === picker.$date.getDate();\n          },\n          isDisabled: function (date) {\n            var time = date.getTime();\n\n              // Disabled because of min/max date.\n            if (time < options.minDate || time > options.maxDate) return true;\n\n              // Disabled due to being a disabled day of the week\n            if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\n\n              // Disabled because of disabled date range.\n            if (options.disabledDateRanges) {\n              for (var i = 0; i < options.disabledDateRanges.length; i++) {\n                if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\n                  return true;\n                }\n              }\n            }\n\n            return false;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualTime = picker.$date.getTime();\n            var newDate;\n\n            if (evt.keyCode === 37) newDate = new Date(actualTime - 1 * 864e5);\n            else if (evt.keyCode === 38) newDate = new Date(actualTime - 7 * 864e5);\n            else if (evt.keyCode === 39) newDate = new Date(actualTime + 1 * 864e5);\n            else if (evt.keyCode === 40) newDate = new Date(actualTime + 7 * 864e5);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }, {\n          name: 'month',\n          format: options.monthFormat,\n          split: 4,\n          steps: {year: 1},\n          update: function (date, force) {\n            if (!this.built || date.getFullYear() !== viewDate.year) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getMonth() !== viewDate.month) {\n              angular.extend(viewDate, {month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            // var firstMonth = new Date(viewDate.year, 0, 1);\n            var months = [];\n            var month;\n            for (var i = 0; i < 12; i++) {\n              month = new Date(viewDate.year, i, 1);\n              months.push({date: month, label: formatDate(month, this.format), selected: picker.$isSelected(month), disabled: this.isDisabled(month)});\n            }\n            scope.title = formatDate(month, options.yearTitleFormat);\n            scope.showLabels = false;\n            scope.rows = split(months, this.split);\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\n          },\n          isDisabled: function (date) {\n            var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualMonth = picker.$date.getMonth();\n            var newDate = new Date(picker.$date);\n\n            if (evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\n            else if (evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\n            else if (evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\n            else if (evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }, {\n          name: 'year',\n          format: options.yearFormat,\n          split: 4,\n          steps: {year: 12},\n          update: function (date, force) {\n            if (!this.built || force || parseInt(date.getFullYear() / 20, 10) !== parseInt(viewDate.year / 20, 10)) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getFullYear() !== viewDate.year) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            var firstYear = viewDate.year - viewDate.year % (this.split * 3);\n            var years = [];\n            var year;\n            for (var i = 0; i < 12; i++) {\n              year = new Date(firstYear + i, 0, 1);\n              years.push({date: year, label: formatDate(year, this.format), selected: picker.$isSelected(year), disabled: this.isDisabled(year)});\n            }\n            scope.title = years[0].label + '-' + years[years.length - 1].label;\n            scope.showLabels = false;\n            scope.rows = split(years, this.split);\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear();\n          },\n          isDisabled: function (date) {\n            var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualYear = picker.$date.getFullYear();\n            var newDate = new Date(picker.$date);\n\n            if (evt.keyCode === 37) newDate.setYear(actualYear - 1);\n            else if (evt.keyCode === 38) newDate.setYear(actualYear - 4);\n            else if (evt.keyCode === 39) newDate.setYear(actualYear + 1);\n            else if (evt.keyCode === 40) newDate.setYear(actualYear + 4);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }];\n\n        return {\n          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\n          viewDate: viewDate\n        };\n\n      };\n\n    };\n\n  });\n\n// Source: module.js\nangular.module('mgcrea.ngStrap', [\n  'mgcrea.ngStrap.datepicker',\n  'mgcrea.ngStrap.timepicker',\n  'mgcrea.ngStrap.tooltip',\n]);\n\n})(window, document);\n","'use strict';\n\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      templateUrl: 'tooltip/tooltip.tpl.html',\n      template: '',\n      titleTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      mouseDownPreventDefault: true,\n      mouseDownStopPropagation: true,\n      viewport: {\n        selector: 'body',\n        padding: 0\n      }\n    };\n\n    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory (element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        var nodeName = element[0].nodeName.toLowerCase();\n        if (options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if (options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function (isEnabled) {\n          scope.$$postDigest(function () {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function () {\n          scope.$$postDigest(function () {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function () {\n          scope.$$postDigest(function () {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function () {\n          scope.$$postDigest(function () {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout;\n        var hoverState;\n\n        // Fetch, compile then initialize tooltip\n        var compileData;\n        var tipElement;\n        var tipContainer;\n        var tipScope;\n        promise.then(function (data) {\n          compileData = data;\n          $tooltip.init();\n        });\n\n        $tooltip.init = function () {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if (options.container === 'self') {\n            tipContainer = element;\n          } else if (angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if (options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if (options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if (options.show) {\n            scope.$$postDigest(function () {\n              if (options.trigger === 'focus') {\n                element[0].focus();\n              } else {\n                $tooltip.show();\n              }\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function () {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function () {\n            if (hoverState === 'in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function () {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\n            options.onBeforeShow($tooltip);\n          }\n          var parent;\n          var after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if (tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if (options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if (options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          if (after) {\n            after.after(tipElement);\n          } else {\n            parent.prepend(tipElement);\n          }\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\n          }\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if (tipElement) tipElement.css({visibility: 'visible'});\n\n            // Bind events\n            if (options.keyboard) {\n              if (options.trigger !== 'focus') {\n                $tooltip.focus();\n              }\n              bindKeyboardEvents();\n            }\n          });\n\n          if (options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n        };\n\n        function enterAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\n            options.onShow($tooltip);\n          }\n        }\n\n        $tooltip.leave = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function (blur) {\n\n          if (!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\n            options.onBeforeHide($tooltip);\n          }\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          if (tipElement !== null) {\n            // Support v1.2+ $animate\n            // https://github.com/angular/angular.js/issues/11713\n            if (angular.version.minor <= 2) {\n              $animate.leave(tipElement, leaveAnimateCallback);\n            } else {\n              $animate.leave(tipElement).then(leaveAnimateCallback);\n            }\n          }\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if (options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if (options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\n            options.onHide($tooltip);\n          }\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if (_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function (evt) {\n          if (evt) { evt.preventDefault(); }\n          if ($tooltip.$isShown) {\n            $tooltip.leave();\n          } else {\n            $tooltip.enter();\n          }\n        };\n\n        $tooltip.focus = function () {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function (isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function (viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function () {\n          if (!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement;\n          var autoToken = /\\s?auto?\\s?/i;\n          var autoPlace = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition();\n          var tipWidth = tipElement.prop('offsetWidth');\n          var tipHeight = tipElement.prop('offsetHeight');\n\n          // Refresh viewport position\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var viewportPosition = getPosition($tooltip.$viewport);\n\n            if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\n              placement = originalPlacement.replace('bottom', 'top');\n            } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {\n              placement = originalPlacement.replace('top', 'bottom');\n            }\n\n            if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {\n              placement = placement.replace('left', 'right');\n            } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {\n              placement = placement.replace('right', 'left');\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function (evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function (evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function (evt) {\n          if (options.mouseDownPreventDefault) { evt.preventDefault(); }\n          if (options.mouseDownStopPropagation) { evt.stopPropagation(); }\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          if ($tooltip.$isShown) {\n            element[0].blur();\n          } else {\n            element[0].focus();\n          }\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents () {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function (trigger) {\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.on(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          });\n        }\n\n        function unbindTriggerEvents () {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.off(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          }\n        }\n\n        function bindKeyboardEvents () {\n          if (options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents () {\n          if (options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents () {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents () {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation (event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition ($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0];\n          var isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          /* eslint-disable guard-for-in */\n          for (var p in elRect) { // eslint-disable-line\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n          /* eslint-enable guard-for-in */\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top});\n          }\n          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\n          var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0};\n          var outerDims = isBody ? {width: document.documentElement.clientWidth, height: $window.innerHeight} : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset (placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n            case 'right':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left + position.width\n              };\n              break;\n            case 'bottom':\n              offset = {\n                top: position.top + position.height,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n            case 'left':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left - actualWidth\n              };\n              break;\n            default:\n              offset = {\n                top: position.top - actualHeight,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n          }\n\n          if (!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if (split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n              case 'left':\n                offset.left = position.left;\n                break;\n              case 'right':\n                offset.left = position.left + position.width - actualWidth;\n                break;\n              default:\n                break;\n            }\n          } else if (split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n              case 'top':\n                offset.top = position.top - actualHeight + position.height;\n                break;\n              case 'bottom':\n                offset.top = position.top;\n                break;\n              default:\n                break;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement (offset, placement) {\n          var tip = tipElement[0];\n          var width = tip.offsetWidth;\n          var height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\n          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px',\n                right: ''\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth;\n          var actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement);\n            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\n            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\n        function getViewportAdjustedDelta (placement, position, actualWidth, actualHeight) {\n          var delta = {top: 0, left: 0};\n          if (!$tooltip.$viewport) return delta;\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\n          var viewportDimensions = getPosition($tooltip.$viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset = position.left - viewportPadding;\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow (delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement () {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if ($tooltip.$isShown && tipElement !== null) {\n            if (options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if (options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if (tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if (tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest (scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      function findElement (query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function ($window, $location, $sce, $parse, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr, transclusion) {\n\n        var tooltip;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function (newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }\n        });\n\n        attr.$observe('disabled', function (newValue) {\n          if (newValue && tooltip.$isShown) {\n            tooltip.hide();\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsTooltip) {\n          scope.$watch(attr.bsTooltip, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.title = newValue;\n            }\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }, true);\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n            if (newValue === true) {\n              tooltip.show();\n            } else {\n              tooltip.hide();\n            }\n          });\n        }\n\n        // Enabled binding support\n        if (attr.bsEnabled) {\n          scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n            if (newValue === false) {\n              tooltip.setEnabled(false);\n            } else {\n              tooltip.setEnabled(true);\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            tooltip.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\n// NOTICE: This file was forked from the angular-material project (github.com/angular/material)\n// MIT Licensed - Copyright (c) 2014-2015 Google, Inc. http://angularjs.org\n\nangular.module('mgcrea.ngStrap.core', [])\n  .service('$bsCompiler', bsCompilerService);\n\nfunction bsCompilerService ($q, $http, $injector, $compile, $controller, $templateCache) {\n\n  /*\n   * @ngdoc service\n   * @name $bsCompiler\n   * @module material.core\n   * @description\n   * The $bsCompiler service is an abstraction of angular's compiler, that allows the developer\n   * to easily compile an element with a templateUrl, controller, and locals.\n   *\n   * @usage\n   * <hljs lang=\"js\">\n   * $bsCompiler.compile({\n   *   templateUrl: 'modal.html',\n   *   controller: 'ModalCtrl',\n   *   locals: {\n   *     modal: myModalInstance;\n   *   }\n   * }).then(function(compileData) {\n   *   compileData.element; // modal.html's template in an element\n   *   compileData.link(myScope); //attach controller & scope to element\n   * });\n   * </hljs>\n   */\n\n   /*\n    * @ngdoc method\n    * @name $bsCompiler#compile\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\n    * locals, and scope.\n    * @param {object} options An options object, with the following properties:\n    *\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\n    *      newly created scope or the name of a registered controller if passed as a string.\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\n    *      published to scope under the `controllerAs` name.\n    *    - `template` - `{string=}` An html template as a string.\n    *    - `templateUrl` - `{string=}` A path to an html template.\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\n    *      it is loaded. It will be given the template string as a parameter, and should\n    *      return a a new string representing the transformed template.\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\n    *      instantiated `compile()` will fail..\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\n    *        Otherwise if function, then it is injected and the return value is treated as the\n    *        dependency. If the result is a promise, it is resolved before its value is\n    *        injected into the controller.\n    *\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\n    * `compileData` has the following properties:\n    *\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\n    *     the element and instantiate the provided controller (if given).\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\n    */\n  this.compile = function (options) {\n\n    if (options.template && /\\.html$/.test(options.template)) {\n      console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');\n      options.templateUrl = options.template;\n      options.template = '';\n    }\n\n    var templateUrl = options.templateUrl;\n    var template = options.template || '';\n    var controller = options.controller;\n    var controllerAs = options.controllerAs;\n    var resolve = options.resolve || {};\n    var locals = options.locals || {};\n    var transformTemplate = options.transformTemplate || angular.identity;\n    var bindToController = options.bindToController;\n\n    // Take resolve values and invoke them.\n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\n    angular.forEach(resolve, function (value, key) {\n      if (angular.isString(value)) {\n        resolve[key] = $injector.get(value);\n      } else {\n        resolve[key] = $injector.invoke(value);\n      }\n    });\n    // Add the locals, which are just straight values to inject\n    // eg locals: { three: 3 }, will inject three into the controller\n    angular.extend(resolve, locals);\n\n    if (template) {\n      resolve.$template = $q.when(template);\n    } else if (templateUrl) {\n      resolve.$template = fetchTemplate(templateUrl);\n    } else {\n      throw new Error('Missing `template` / `templateUrl` option.');\n    }\n\n    if (options.titleTemplate) {\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.titleTemplate)])\n        .then(function (templates) {\n          var templateEl = angular.element(templates[0]);\n          findElement('[ng-bind=\"title\"]', templateEl[0])\n            .removeAttr('ng-bind')\n            .html(templates[1]);\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    if (options.contentTemplate) {\n      // TODO(mgcrea): deprecate?\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.contentTemplate)])\n        .then(function (templates) {\n          var templateEl = angular.element(templates[0]);\n          var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0])\n            .removeAttr('ng-bind')\n            .html(templates[1]);\n          // Drop the default footer as you probably don't want it if you use a custom contentTemplate\n          if (!options.templateUrl) contentEl.next().remove();\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    // Wait for all the resolves to finish if they are promises\n    return $q.all(resolve).then(function (locals) {\n\n      var template = transformTemplate(locals.$template);\n      if (options.html) {\n        template = template.replace(/ng-bind=\"/ig, 'ng-bind-html=\"');\n      }\n      // var element = options.element || angular.element('<div>').html(template.trim()).contents();\n      var element = angular.element('<div>').html(template.trim()).contents();\n      var linkFn = $compile(element);\n\n      // Return a linking function that can be used later when the element is ready\n      return {\n        locals: locals,\n        element: element,\n        link: function link (scope) {\n          locals.$scope = scope;\n\n          // Instantiate controller if it exists, because we have scope\n          if (controller) {\n            var invokeCtrl = $controller(controller, locals, true);\n            if (bindToController) {\n              angular.extend(invokeCtrl.instance, locals);\n            }\n            // Support angular@~1.2 invokeCtrl\n            var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();\n            // See angular-route source for this logic\n            element.data('$ngControllerController', ctrl);\n            element.children().data('$ngControllerController', ctrl);\n\n            if (controllerAs) {\n              scope[controllerAs] = ctrl;\n            }\n          }\n\n          return linkFn.apply(null, arguments);\n        }\n      };\n    });\n\n  };\n\n  function findElement (query, element) {\n    return angular.element((element || document).querySelectorAll(query));\n  }\n\n  var fetchPromises = {};\n  function fetchTemplate (template) {\n    if (fetchPromises[template]) return fetchPromises[template];\n    return (fetchPromises[template] = $http.get(template, {cache: $templateCache})\n      .then(function (res) {\n        return res.data;\n      }));\n  }\n\n}\n","'use strict';\n\nangular.module('mgcrea.ngStrap.timepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip'])\n\n  .provider('$timepicker', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      defaultDate: 'auto',\n      // uncommenting the following line will break backwards compatability\n      // prefixEvent: 'timepicker',\n      prefixClass: 'timepicker',\n      placement: 'bottom-left',\n      templateUrl: 'timepicker/timepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: true,\n      timeType: 'date',\n      timeFormat: 'shortTime',\n      timezone: null,\n      modelTimeFormat: null,\n      autoclose: false,\n      minTime: -Infinity,\n      maxTime: +Infinity,\n      length: 5,\n      hourStep: 1,\n      minuteStep: 5,\n      secondStep: 5,\n      roundDisplay: false,\n      iconUp: 'glyphicon glyphicon-chevron-up',\n      iconDown: 'glyphicon glyphicon-chevron-down',\n      arrowBehavior: 'pager'\n    };\n\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if (!defaults.lang) {\n        defaults.lang = $dateFormatter.getDefaultLocale();\n      }\n\n      function timepickerFactory (element, controller, config) {\n\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $timepicker.$options;\n        var scope = $timepicker.$scope;\n\n        var lang = options.lang;\n        var formatDate = function (date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        function floorMinutes (time) {\n          // coeff used to floor current time to nearest minuteStep interval\n          var coeff = 1000 * 60 * options.minuteStep;\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\n        }\n\n        // View vars\n\n        var selectedIndex = 0;\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\n        var startDate = controller.$dateValue || defaultDate;\n        var viewDate = {\n          hour: startDate.getHours(),\n          meridian: startDate.getHours() < 12,\n          minute: startDate.getMinutes(),\n          second: startDate.getSeconds(),\n          millisecond: startDate.getMilliseconds()\n        };\n\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\n\n        var hoursFormat = $dateFormatter.hoursFormat(format);\n        var timeSeparator = $dateFormatter.timeSeparator(format);\n        var minutesFormat = $dateFormatter.minutesFormat(format);\n        var secondsFormat = $dateFormatter.secondsFormat(format);\n        var showSeconds = $dateFormatter.showSeconds(format);\n        var showAM = $dateFormatter.showAM(format);\n\n        scope.$iconUp = options.iconUp;\n        scope.$iconDown = options.iconDown;\n\n        // Scope methods\n\n        scope.$select = function (date, index) {\n          $timepicker.select(date, index);\n        };\n        scope.$moveIndex = function (value, index) {\n          $timepicker.$moveIndex(value, index);\n        };\n        scope.$switchMeridian = function (date) {\n          $timepicker.switchMeridian(date);\n        };\n\n        // Public methods\n\n        $timepicker.update = function (date) {\n          // console.warn('$timepicker.update() newValue=%o', date);\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\n            $timepicker.$date = date;\n            angular.extend(viewDate, {\n              hour: date.getHours(),\n              minute: date.getMinutes(),\n              second: date.getSeconds(),\n              millisecond: date.getMilliseconds()\n            });\n            $timepicker.$build();\n          } else if (!$timepicker.$isBuilt) {\n            $timepicker.$build();\n          }\n        };\n\n        $timepicker.select = function (date, index, keep) {\n          // console.warn('$timepicker.select', date, scope.$mode);\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n            controller.$dateValue = options.defaultDate === 'today' ? new Date() : new Date(1970, 0, 1);\n          }\n\n          if (!angular.isDate(date)) date = new Date(date);\n          if (index === 0) controller.$dateValue.setHours(date.getHours());\n          else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes());\n          else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n          if (options.autoclose && !keep) {\n            $timeout(function () {\n              $timepicker.hide(true);\n            });\n          }\n        };\n\n        $timepicker.switchMeridian = function (date) {\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n            return;\n          }\n          var hours = (date || controller.$dateValue).getHours();\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n        };\n\n        // Protected methods\n\n        $timepicker.$build = function () {\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\n          var i;\n          var midIndex = scope.midIndex = parseInt(options.length / 2, 10);\n          var hours = [];\n          var hour;\n          for (i = 0; i < options.length; i++) {\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\n            hours.push({\n              date: hour,\n              label: formatDate(hour, hoursFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),\n              disabled: $timepicker.$isDisabled(hour, 0)\n            });\n          }\n          var minutes = [];\n          var minute;\n          for (i = 0; i < options.length; i++) {\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\n            minutes.push({\n              date: minute,\n              label: formatDate(minute, minutesFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),\n              disabled: $timepicker.$isDisabled(minute, 1)\n            });\n          }\n          var seconds = [];\n          var second;\n          for (i = 0; i < options.length; i++) {\n            second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);\n            seconds.push({\n              date: second,\n              label: formatDate(second, secondsFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(second, 2),\n              disabled: $timepicker.$isDisabled(second, 2)\n            });\n          }\n\n          var rows = [];\n          for (i = 0; i < options.length; i++) {\n            if (showSeconds) {\n              rows.push([hours[i], minutes[i], seconds[i]]);\n            } else {\n              rows.push([hours[i], minutes[i]]);\n            }\n          }\n          scope.rows = rows;\n          scope.showSeconds = showSeconds;\n          scope.showAM = showAM;\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\n          scope.timeSeparator = timeSeparator;\n          $timepicker.$isBuilt = true;\n        };\n\n        $timepicker.$isSelected = function (date, index) {\n          if (!$timepicker.$date) return false;\n          else if (index === 0) {\n            return date.getHours() === $timepicker.$date.getHours();\n          } else if (index === 1) {\n            return date.getMinutes() === $timepicker.$date.getMinutes();\n          } else if (index === 2) {\n            return date.getSeconds() === $timepicker.$date.getSeconds();\n          }\n        };\n\n        $timepicker.$isDisabled = function (date, index) {\n          var selectedTime;\n          if (index === 0) {\n            selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;\n          } else if (index === 1) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;\n          } else if (index === 2) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;\n          }\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\n        };\n\n        scope.$arrowAction = function (value, index) {\n          if (options.arrowBehavior === 'picker') {\n            $timepicker.$setTimeByStep(value, index);\n          } else {\n            $timepicker.$moveIndex(value, index);\n          }\n        };\n\n        $timepicker.$setTimeByStep = function (value, index) {\n          var newDate = new Date($timepicker.$date || startDate);\n          var hours = newDate.getHours();\n          var minutes = newDate.getMinutes();\n          var seconds = newDate.getSeconds();\n          if (index === 0) {\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\n          } else if (index === 1) {\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\n          } else if (index === 2) {\n            newDate.setSeconds(seconds - (parseInt(options.secondStep, 10) * value));\n          }\n          $timepicker.select(newDate, index, true);\n        };\n\n        $timepicker.$moveIndex = function (value, index) {\n          var targetDate;\n          if (index === 0) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute, viewDate.second);\n            angular.extend(viewDate, {\n              hour: targetDate.getHours()\n            });\n          } else if (index === 1) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep), viewDate.second);\n            angular.extend(viewDate, {\n              minute: targetDate.getMinutes()\n            });\n          } else if (index === 2) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + (value * options.length * options.secondStep));\n            angular.extend(viewDate, {\n              second: targetDate.getSeconds()\n            });\n          }\n          $timepicker.$build();\n        };\n\n        $timepicker.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $timepicker.$onKeyDown = function (evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Close on enter\n          if (evt.keyCode === 13) {\n            $timepicker.hide(true);\n            return;\n          }\n\n          // Navigate with keyboard\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours();\n          var hoursLength = formatDate(newDate, hoursFormat).length;\n          var minutes = newDate.getMinutes();\n          var minutesLength = formatDate(newDate, minutesFormat).length;\n          var seconds = newDate.getSeconds();\n          var secondsLength = formatDate(newDate, secondsFormat).length;\n          var sepLength = 1;\n          var lateralMove = /(37|39)/.test(evt.keyCode);\n          var count = 2 + showSeconds * 1 + showAM * 1;\n\n          // Navigate indexes (left, right)\n          if (lateralMove) {\n            if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\n            else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\n          }\n\n          // Update values (up, down)\n          var selectRange = [0, hoursLength];\n          var incr = 0;\n          if (evt.keyCode === 38) incr = -1;\n          if (evt.keyCode === 40) incr = +1;\n          var isSeconds = selectedIndex === 2 && showSeconds;\n          var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;\n          if (selectedIndex === 0) {\n            newDate.setHours(hours + incr * parseInt(options.hourStep, 10));\n            // re-calculate hours length because we have changed hours value\n            hoursLength = formatDate(newDate, hoursFormat).length;\n            selectRange = [0, hoursLength];\n          } else if (selectedIndex === 1) {\n            newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));\n            // re-calculate minutes length because we have changes minutes value\n            minutesLength = formatDate(newDate, minutesFormat).length;\n            selectRange = [hoursLength + sepLength, minutesLength];\n          } else if (isSeconds) {\n            newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));\n            // re-calculate seconds length because we have changes seconds value\n            secondsLength = formatDate(newDate, secondsFormat).length;\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength, secondsLength];\n          } else if (isMeridian) {\n            if (!lateralMove) $timepicker.switchMeridian();\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2];\n          }\n          $timepicker.select(newDate, selectedIndex, true);\n          createSelection(selectRange[0], selectRange[1]);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function createSelection (start, length) {\n          var end = start + length;\n          if (element[0].createTextRange) {\n            var selRange = element[0].createTextRange();\n            selRange.collapse(true);\n            selRange.moveStart('character', start);\n            selRange.moveEnd('character', end);\n            selRange.select();\n          } else if (element[0].setSelectionRange) {\n            element[0].setSelectionRange(start, end);\n          } else if (angular.isUndefined(element[0].selectionStart)) {\n            element[0].selectionStart = start;\n            element[0].selectionEnd = end;\n          }\n        }\n\n        function focusElement () {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $timepicker.init;\n        $timepicker.init = function () {\n          if (isNative && options.useNative) {\n            element.prop('type', 'time');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if (isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $timepicker.destroy;\n        $timepicker.destroy = function () {\n          if (isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $timepicker.show;\n        $timepicker.show = function () {\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            if ($timepicker.$element) $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n            if (options.keyboard) {\n              if (element) element.on('keydown', $timepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $timepicker.hide;\n        $timepicker.hide = function (blur) {\n          if (!$timepicker.$isShown) return;\n          if ($timepicker.$element) $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n          if (options.keyboard) {\n            if (element) element.off('keydown', $timepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $timepicker;\n\n      }\n\n      timepickerFactory.defaults = defaults;\n      return timepickerFactory;\n\n    };\n\n  })\n\n\n  .directive('bsTimepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\n\n    var defaults = $timepicker.defaults;\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink (scope, element, attr, controller) {\n\n        // Directive options\n        var options = {\n          scope: scope\n        };\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent', 'defaultDate'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'roundDisplay'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // Initialize timepicker\n        if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\n        var timepicker = $timepicker(element, controller, options);\n        options = timepicker.$options;\n\n        var lang = options.lang;\n        var formatDate = function (date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!timepicker || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\n            if (newValue === true) {\n              timepicker.show();\n            } else {\n              timepicker.hide();\n            }\n          });\n        }\n\n        // Initialize parser\n        var dateParser = $dateParser({\n          format: options.timeFormat,\n          lang: lang\n        });\n\n        // Observe attributes for changes\n        angular.forEach(['minTime', 'maxTime'], function (key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          if (angular.isDefined(attr[key])) {\n            attr.$observe(key, function (newValue) {\n              timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\n              if (!isNaN(timepicker.$options[key])) timepicker.$build();\n              validateAgainstMinMaxTime(controller.$dateValue);\n            });\n          }\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\n          timepicker.update(controller.$dateValue);\n        }, true);\n\n        function validateAgainstMinMaxTime (parsedTime) {\n          if (!angular.isDate(parsedTime)) return;\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if (!isValid) {\n            return;\n          }\n          controller.$dateValue = parsedTime;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function (viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if (!viewValue) {\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            controller.$setValidity('date', true);\n            return null;\n          }\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\n          if (!parsedTime || isNaN(parsedTime.getTime())) {\n            controller.$setValidity('date', false);\n            // Return undefined, causes ngModelController to\n            // invalidate model value\n            return undefined;\n          }\n          validateAgainstMinMaxTime(parsedTime);\n\n          if (options.timeType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\n            return formatDate(date, options.modelTimeFormat || options.timeFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if (options.timeType === 'number') {\n            return date.getTime();\n          } else if (options.timeType === 'unix') {\n            return date.getTime() / 1000;\n          } else if (options.timeType === 'iso') {\n            return date.toISOString();\n          }\n          return new Date(date);\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if (angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if (angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if (options.timeType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\n          } else if (options.timeType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getTimeFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function () {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getTimeFormattedString());\n        };\n\n        function getTimeFormattedString () {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (timepicker) timepicker.destroy();\n          options = null;\n          timepicker = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nif (angular.version.minor < 3 && angular.version.dot < 14) {\n  angular.module('ng')\n\n  .factory('$$rAF', function ($window, $timeout) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame ||\n                                $window.webkitRequestAnimationFrame ||\n                                $window.mozRequestAnimationFrame;\n\n    var cancelAnimationFrame = $window.cancelAnimationFrame ||\n                               $window.webkitCancelAnimationFrame ||\n                               $window.mozCancelAnimationFrame ||\n                               $window.webkitCancelRequestAnimationFrame;\n\n    var rafSupported = !!requestAnimationFrame;\n    var raf = rafSupported ?\n      function (fn) {\n        var id = requestAnimationFrame(fn);\n        return function () {\n          cancelAnimationFrame(id);\n        };\n      } :\n      function (fn) {\n        var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\n        return function () {\n          $timeout.cancel(timer);\n        };\n      };\n\n    raf.supported = rafSupported;\n\n    return raf;\n\n  });\n}\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\n\n  .provider('$parseOptions', function () {\n\n    var defaults = this.defaults = {\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\n    };\n\n    this.$get = function ($parse, $q) {\n\n      function ParseOptionsFactory (attr, config) {\n\n        var $parseOptions = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        $parseOptions.$values = [];\n\n        // Private vars\n        var match;\n        var displayFn;\n        var valueName;\n        /* eslint-disable no-unused-vars */\n        var keyName;\n        var groupByFn;\n        /* eslint-enable no-unused-vars */\n        var valueFn;\n        var valuesFn;\n\n        $parseOptions.init = function () {\n          $parseOptions.$match = match = attr.match(options.regexp);\n          displayFn = $parse(match[2] || match[1]);\n          valueName = match[4] || match[6];\n          keyName = match[5];\n          groupByFn = $parse(match[3] || '');\n          valueFn = $parse(match[2] ? match[1] : valueName);\n          valuesFn = $parse(match[7]);\n        };\n\n        $parseOptions.valuesFn = function (scope, controller) {\n          return $q.when(valuesFn(scope, controller))\n          .then(function (values) {\n            if (!angular.isArray(values)) {\n              values = [];\n            }\n            $parseOptions.$values = values.length ? parseValues(values, scope) : [];\n            return $parseOptions.$values;\n          });\n        };\n\n        $parseOptions.displayValue = function (modelValue) {\n          var scope = {};\n          scope[valueName] = modelValue;\n          return displayFn(scope);\n        };\n\n        // Private functions\n\n        function parseValues (values, scope) {\n          return values.map(function (match, index) {\n            var locals = {};\n            var label;\n            var value;\n            locals[valueName] = match;\n            label = displayFn(scope, locals);\n            value = valueFn(scope, locals);\n            return {label: label, value: value, index: index};\n          });\n        }\n\n        $parseOptions.init();\n        return $parseOptions;\n\n      }\n\n      return ParseOptionsFactory;\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\n\n  .factory('dimensions', function () {\n\n    var fn = {};\n\n    /**\n     * Test the element nodeName\n     * @param element\n     * @param name\n     */\n    var nodeName = fn.nodeName = function (element, name) {\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\n    };\n\n    /**\n     * Returns the element computed style\n     * @param element\n     * @param prop\n     * @param extra\n     */\n    fn.css = function (element, prop, extra) {\n      var value;\n      if (element.currentStyle) { // IE\n        value = element.currentStyle[prop];\n      } else if (window.getComputedStyle) {\n        value = window.getComputedStyle(element)[prop];\n      } else {\n        value = element.style[prop];\n      }\n      return extra === true ? parseFloat(value) || 0 : value;\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.offset = function (element) {\n      var boxRect = element.getBoundingClientRect();\n      var docElement = element.ownerDocument;\n      return {\n        width: boxRect.width || element.offsetWidth,\n        height: boxRect.height || element.offsetHeight,\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\n      };\n    };\n\n    /**\n     * Provides set equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip\n     * @url http://api.jquery.com/offset/\n     * @param element\n     * @param options\n     * @param i\n     */\n    fn.setOffset = function (element, options, i) {\n      var curPosition;\n      var curLeft;\n      var curCSSTop;\n      var curTop;\n      var curOffset;\n      var curCSSLeft;\n      var calculatePosition;\n      var position = fn.css(element, 'position');\n      var curElem = angular.element(element);\n      var props = {};\n\n      // Set position first, in-case top/left are set even on static elem\n      if (position === 'static') {\n        element.style.position = 'relative';\n      }\n\n      curOffset = fn.offset(element);\n      curCSSTop = fn.css(element, 'top');\n      curCSSLeft = fn.css(element, 'left');\n      calculatePosition = (position === 'absolute' || position === 'fixed') &&\n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\n\n      // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n      if (calculatePosition) {\n        curPosition = fn.position(element);\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n\n      if (angular.isFunction(options)) {\n        options = options.call(element, i, curOffset);\n      }\n\n      if (options.top !== null) {\n        props.top = (options.top - curOffset.top) + curTop;\n      }\n      if (options.left !== null) {\n        props.left = (options.left - curOffset.left) + curLeft;\n      }\n\n      if ('using' in options) {\n        options.using.call(curElem, props);\n      } else {\n        curElem.css({\n          top: props.top + 'px',\n          left: props.left + 'px'\n        });\n      }\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's position function\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.position = function (element) {\n\n      var offsetParentRect = {top: 0, left: 0};\n      var offsetParentEl;\n      var offset;\n\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n      if (fn.css(element, 'position') === 'fixed') {\n\n        // We assume that getBoundingClientRect is available when computed position is fixed\n        offset = element.getBoundingClientRect();\n\n      } else {\n\n        // Get *real* offsetParentEl\n        offsetParentEl = offsetParentElement(element);\n\n        // Get correct offsets\n        offset = fn.offset(element);\n        if (!nodeName(offsetParentEl, 'html')) {\n          offsetParentRect = fn.offset(offsetParentEl);\n        }\n\n        // Add offsetParent borders\n        offsetParentRect.top += fn.css(offsetParentEl, 'borderTopWidth', true);\n        offsetParentRect.left += fn.css(offsetParentEl, 'borderLeftWidth', true);\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\n      };\n\n    };\n\n    /**\n     * Returns the closest, non-statically positioned offsetParent of a given element\n     * @required-by fn.position\n     * @param element\n     */\n    function offsetParentElement (element) {\n      var docElement = element.ownerDocument;\n      var offsetParent = element.offsetParent || docElement;\n      if (nodeName(offsetParent, '#document')) return docElement.documentElement;\n      while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docElement.documentElement;\n    }\n\n    /**\n     * Provides equivalent of jQuery's height function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/height/\n     * @param element\n     * @param outer\n     */\n    fn.height = function (element, outer) {\n      var value = element.offsetHeight;\n      if (outer) {\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\n      } else {\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\n      }\n      return value;\n    };\n\n    /**\n     * Provides equivalent of jQuery's width function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/width/\n     * @param element\n     * @param outer\n     */\n    fn.width = function (element, outer) {\n      var value = element.offsetWidth;\n      if (outer) {\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\n      } else {\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\n      }\n      return value;\n    };\n\n    return fn;\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\n.factory('debounce', function ($timeout) {\n  return function (func, wait, immediate) {\n    var timeout = null;\n    return function () {\n      var context = this;\n      var args = arguments;\n      var callNow = immediate && !timeout;\n      if (timeout) {\n        $timeout.cancel(timeout);\n      }\n      timeout = $timeout(function later () {\n        timeout = null;\n        if (!immediate) {\n          func.apply(context, args);\n        }\n      }, wait, false);\n      if (callNow) {\n        func.apply(context, args);\n      }\n      return timeout;\n    };\n  };\n})\n\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\n.factory('throttle', function ($timeout) {\n  return function (func, wait, options) {\n    var timeout = null;\n    if (!options) options = {};\n    return function () {\n      var context = this;\n      var args = arguments;\n      if (!timeout) {\n        if (options.leading !== false) {\n          func.apply(context, args);\n        }\n        timeout = $timeout(function later () {\n          timeout = null;\n          if (options.trailing !== false) {\n            func.apply(context, args);\n          }\n        }, wait, false);\n      }\n    };\n  };\n});\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\n\n.provider('$dateParser', function ($localeProvider) {\n\n  // define a custom ParseDate object to use instead of native Date\n  // to avoid date values wrapping when setting date component values\n  function ParseDate () {\n    this.year = 1970;\n    this.month = 0;\n    this.day = 1;\n    this.hours = 0;\n    this.minutes = 0;\n    this.seconds = 0;\n    this.milliseconds = 0;\n  }\n\n  ParseDate.prototype.setMilliseconds = function (value) { this.milliseconds = value; };\n  ParseDate.prototype.setSeconds = function (value) { this.seconds = value; };\n  ParseDate.prototype.setMinutes = function (value) { this.minutes = value; };\n  ParseDate.prototype.setHours = function (value) { this.hours = value; };\n  ParseDate.prototype.getHours = function () { return this.hours; };\n  ParseDate.prototype.setDate = function (value) { this.day = value; };\n  ParseDate.prototype.setMonth = function (value) { this.month = value; };\n  ParseDate.prototype.setFullYear = function (value) { this.year = value; };\n  ParseDate.prototype.fromDate = function (value) {\n    this.year = value.getFullYear();\n    this.month = value.getMonth();\n    this.day = value.getDate();\n    this.hours = value.getHours();\n    this.minutes = value.getMinutes();\n    this.seconds = value.getSeconds();\n    this.milliseconds = value.getMilliseconds();\n    return this;\n  };\n\n  ParseDate.prototype.toDate = function () {\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\n  };\n\n  var proto = ParseDate.prototype;\n\n  function noop () {\n  }\n\n  function isNumeric (n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function indexOfCaseInsensitive (array, value) {\n    var len = array.length;\n    var str = value.toString().toLowerCase();\n    for (var i = 0; i < len; i++) {\n      if (array[i].toLowerCase() === str) { return i; }\n    }\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\n  }\n\n  var defaults = this.defaults = {\n    format: 'shortDate',\n    strict: false\n  };\n\n  this.$get = function ($locale, dateFilter) {\n\n    var DateParserFactory = function (config) {\n\n      var options = angular.extend({}, defaults, config);\n\n      var $dateParser = {};\n\n      /* eslint-disable key-spacing, quote-props */\n      var regExpMap = {\n        'sss'   : '[0-9]{3}',\n        'ss'    : '[0-5][0-9]',\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'mm'    : '[0-5][0-9]',\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'HH'    : '[01][0-9]|2[0-3]',\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\n        'hh'    : '[0][1-9]|[1][012]',\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'a'     : 'AM|PM',\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        'MM'    : '0[1-9]|1[012]',\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\n        'yy'    : '[0-9]{2}',\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'\n      };\n\n      var setFnMap = {\n        'sss'   : proto.setMilliseconds,\n        'ss'    : proto.setSeconds,\n        's'     : proto.setSeconds,\n        'mm'    : proto.setMinutes,\n        'm'     : proto.setMinutes,\n        'HH'    : proto.setHours,\n        'H'     : proto.setHours,\n        'hh'    : proto.setHours,\n        'h'     : proto.setHours,\n        'EEEE'  : noop,\n        'EEE'   : noop,\n        'dd'    : proto.setDate,\n        'd'     : proto.setDate,\n        'a'     : function (value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\n        'MMMM'  : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\n        'MMM'   : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\n        'MM'    : function (value) { return this.setMonth(1 * value - 1); },\n        'M'     : function (value) { return this.setMonth(1 * value - 1); },\n        'yyyy'  : proto.setFullYear,\n        'yy'    : function (value) { return this.setFullYear(2000 + 1 * value); },\n        'y'     : function (value) { return (1 * value <= 50 && value.length === 2) ? this.setFullYear(2000 + 1 * value) : this.setFullYear(1 * value); }\n      };\n      /* eslint-enable key-spacing, quote-props */\n\n      var regex;\n      var setMap;\n\n      $dateParser.init = function () {\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\n        regex = regExpForFormat($dateParser.$format);\n        setMap = setMapForFormat($dateParser.$format);\n      };\n\n      $dateParser.isValid = function (date) {\n        if (angular.isDate(date)) return !isNaN(date.getTime());\n        return regex.test(date);\n      };\n\n      $dateParser.parse = function (value, baseDate, format, timezone) {\n        // check for date format special names\n        if (format) format = $locale.DATETIME_FORMATS[format] || format;\n        if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\n        var formatRegex = format ? regExpForFormat(format) : regex;\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\n        var matches = formatRegex.exec(value);\n        if (!matches) return false;\n        // use custom ParseDate object to set parsed values\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\n        for (var i = 0; i < matches.length - 1; i++) {\n          if (formatSetMap[i]) formatSetMap[i].call(date, matches[i + 1]);\n        }\n        // convert back to native Date object\n        var newDate = date.toDate();\n\n        // check new native Date object for day values overflow\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\n          return false;\n        }\n\n        return newDate;\n      };\n\n      $dateParser.getDateForAttribute = function (key, value) {\n        var date;\n\n        if (value === 'today') {\n          var today = new Date();\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\n          date = new Date(value.substr(1, value.length - 2));\n        } else if (isNumeric(value)) {\n          date = new Date(parseInt(value, 10));\n        } else if (angular.isString(value) && value.length === 0) { // Reset date\n          date = key === 'minDate' ? -Infinity : +Infinity;\n        } else {\n          date = new Date(value);\n        }\n\n        return date;\n      };\n\n      $dateParser.getTimeForAttribute = function (key, value) {\n        var time;\n\n        if (value === 'now') {\n          time = new Date().setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) {\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\n        } else if (isNumeric(value)) {\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && value.length === 0) { // Reset time\n          time = key === 'minTime' ? -Infinity : +Infinity;\n        } else {\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\n        }\n\n        return time;\n      };\n\n      /* Handle switch to/from daylight saving.\n      * Hours may be non-zero on daylight saving cut-over:\n      * > 12 when midnight changeover, but then cannot generate\n      * midnight datetime, so jump to 1AM, otherwise reset.\n      * @param  date  (Date) the date to check\n      * @return  (Date) the corrected date\n      *\n      * __ copied from jquery ui datepicker __\n      */\n      $dateParser.daylightSavingAdjust = function (date) {\n        if (!date) {\n          return null;\n        }\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n        return date;\n      };\n\n      /* Correct the date for timezone offset.\n      * @param  date  (Date) the date to adjust\n      * @param  timezone  (string) the timezone to adjust for\n      * @param  undo  (boolean) to add or subtract timezone offset\n      * @return  (Date) the corrected date\n      */\n      $dateParser.timezoneOffsetAdjust = function (date, timezone, undo) {\n        if (!date) {\n          return null;\n        }\n        // Right now, only 'UTC' is supported.\n        if (timezone && timezone === 'UTC') {\n          date = new Date(date.getTime());\n          date.setMinutes(date.getMinutes() + (undo ? -1 : 1) * date.getTimezoneOffset());\n        }\n        return date;\n      };\n\n      // Private functions\n\n      function regExpForFormat (format) {\n        // `format` string can contain literal values.\n        // These need to be escaped by surrounding with\n        // single quotes (e.g. `\"h 'in the morning'\"`).\n        // In order to output a single quote, escape it - i.e.,\n        // two single quotes in a sequence (e.g. `\"h 'o''clock'\"`).\n\n        var re = buildDateAbstractRegex(format);\n        return buildDateParseRegex(re);\n      }\n\n      function buildDateAbstractRegex (format) {\n        var escapedFormat = escapeReservedSymbols(format);\n        var escapedLiteralFormat = escapedFormat.replace(/''/g, '\\\\\\'');\n        var literalRegex = /('(?:\\\\'|.)*?')/;\n        var formatParts = escapedLiteralFormat.split(literalRegex);\n        var dateElements = Object.keys(regExpMap);\n        var dateRegexParts = [];\n\n        angular.forEach(formatParts, function (part) {\n          if (isFormatStringLiteral(part)) {\n            part = trimLiteralEscapeChars(part);\n          } else {\n            // Abstract replaces to avoid collisions\n            for (var i = 0; i < dateElements.length; i++) {\n              part = part.split(dateElements[i]).join('${' + i + '}');\n            }\n          }\n          dateRegexParts.push(part);\n        });\n\n        return dateRegexParts.join('');\n      }\n\n      function escapeReservedSymbols (text) {\n        return text.replace(/\\\\/g, '[\\\\\\\\]')\n                   .replace(/-/g, '[-]')\n                   .replace(/\\./g, '[.]')\n                   .replace(/\\*/g, '[*]')\n                   .replace(/\\+/g, '[+]')\n                   .replace(/\\?/g, '[?]')\n                   .replace(/\\$/g, '[$]')\n                   .replace(/\\^/g, '[^]')\n                   .replace(/\\//g, '[/]')\n                   .replace(/\\\\s/g, '[\\\\s]');\n      }\n\n      function isFormatStringLiteral (text) {\n        return /^'.*'$/.test(text);\n      }\n\n      function trimLiteralEscapeChars (text) {\n        return text.replace(/^'(.*)'$/, '$1');\n      }\n\n      function buildDateParseRegex (abstractRegex) {\n        var dateElements = Object.keys(regExpMap);\n        var re = abstractRegex;\n\n        // Replace abstracted values\n        for (var i = 0; i < dateElements.length; i++) {\n          re = re.split('${' + i + '}').join('(' + regExpMap[dateElements[i]] + ')');\n        }\n\n        return new RegExp('^' + re + '$', ['i']);\n      }\n\n      function setMapForFormat (format) {\n        var re = buildDateAbstractRegex(format);\n        return buildDateParseValuesMap(re);\n      }\n\n      function buildDateParseValuesMap (abstractRegex) {\n        var dateElements = Object.keys(regExpMap);\n        var valuesRegex = new RegExp('\\\\${(\\\\d+)}', 'g');\n        var valuesMatch;\n        var keyIndex;\n        var valueKey;\n        var valueFunction;\n        var valuesFunctionMap = [];\n\n        /* eslint-disable no-cond-assign */\n        while ((valuesMatch = valuesRegex.exec(abstractRegex)) !== null) {\n          keyIndex = valuesMatch[1];\n          valueKey = dateElements[keyIndex];\n          valueFunction = setFnMap[valueKey];\n\n          valuesFunctionMap.push(valueFunction);\n        }\n\n        return valuesFunctionMap;\n      }\n\n      $dateParser.init();\n      return $dateParser;\n\n    };\n\n    return DateParserFactory;\n\n  };\n\n});\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\n\n  .service('$dateFormatter', function ($locale, dateFilter) {\n\n    // The unused `lang` arguments are on purpose. The default implementation does not\n    // use them and it always uses the locale loaded into the `$locale` service.\n    // Custom implementations might use it, thus allowing different directives to\n    // have different languages.\n\n    this.getDefaultLocale = function () {\n      return $locale.id;\n    };\n\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\n    // Return either the corresponding date format or the given date format.\n    this.getDatetimeFormat = function (format, lang) {\n      return $locale.DATETIME_FORMATS[format] || format;\n    };\n\n    this.weekdaysShort = function (lang) {\n      return $locale.DATETIME_FORMATS.SHORTDAY;\n    };\n\n    function splitTimeFormat (format) {\n      return /(h+)([:\\.])?(m+)([:\\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);\n    }\n\n    // h:mm a => h\n    this.hoursFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[0];\n    };\n\n    // h:mm a => mm\n    this.minutesFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[2];\n    };\n\n    // h:mm:ss a => ss\n    this.secondsFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => :\n    this.timeSeparator = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[1];\n    };\n\n    // h:mm:ss a => true, h:mm a => false\n    this.showSeconds = function (timeFormat) {\n      return !!splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => true, H.mm => false\n    this.showAM = function (timeFormat) {\n      return !!splitTimeFormat(timeFormat)[5];\n    };\n\n    this.formatDate = function (date, format, lang, timezone) {\n      return dateFilter(date, format, timezone);\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.datepicker', [\n  'mgcrea.ngStrap.helpers.dateParser',\n  'mgcrea.ngStrap.helpers.dateFormatter',\n  'mgcrea.ngStrap.tooltip'])\n\n  .provider('$datepicker', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      // Uncommenting the following line will break backwards compatability\n      // prefixEvent: 'datepicker',\n      prefixClass: 'datepicker',\n      placement: 'bottom-left',\n      templateUrl: 'datepicker/datepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: false,\n      dateType: 'date',\n      dateFormat: 'shortDate',\n      timezone: null,\n      modelDateFormat: null,\n      dayFormat: 'dd',\n      monthFormat: 'MMM',\n      yearFormat: 'yyyy',\n      monthTitleFormat: 'MMMM yyyy',\n      yearTitleFormat: 'yyyy',\n      strictFormat: false,\n      autoclose: false,\n      minDate: -Infinity,\n      maxDate: +Infinity,\n      startView: 0,\n      minView: 0,\n      startWeek: 0,\n      daysOfWeekDisabled: '',\n      hasToday: false,\n      hasClear: false,\n      iconLeft: 'glyphicon glyphicon-chevron-left',\n      iconRight: 'glyphicon glyphicon-chevron-right'\n    };\n\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if (!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n      function DatepickerFactory (element, controller, config) {\n\n        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $datepicker.$options;\n        var scope = $datepicker.$scope;\n        if (options.startView) options.startView -= options.minView;\n\n        // View vars\n\n        var pickerViews = datepickerViews($datepicker);\n        $datepicker.$views = pickerViews.views;\n        var viewDate = pickerViews.viewDate;\n        scope.$mode = options.startView;\n        scope.$iconLeft = options.iconLeft;\n        scope.$iconRight = options.iconRight;\n        scope.$hasToday = options.hasToday;\n        scope.$hasClear = options.hasClear;\n        var $picker = $datepicker.$views[scope.$mode];\n\n        // Scope methods\n\n        scope.$select = function (date, disabled) {\n          if (disabled) return;\n          $datepicker.select(date);\n        };\n        scope.$selectPane = function (value) {\n          $datepicker.$selectPane(value);\n        };\n        scope.$toggleMode = function () {\n          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\n        };\n        scope.$setToday = function () {\n          if (options.autoclose) {\n            $datepicker.setMode(0);\n            $datepicker.select(new Date());\n          } else {\n            $datepicker.select(new Date(), true);\n          }\n        };\n        scope.$clear = function () {\n          if (options.autoclose) {\n            $datepicker.setMode(0);\n            $datepicker.select(null);\n          } else {\n            $datepicker.select(null, true);\n          }\n        };\n\n        // Public methods\n\n        $datepicker.update = function (date) {\n          // console.warn('$datepicker.update() newValue=%o', date);\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\n            $datepicker.$date = date;\n            $picker.update.call($picker, date);\n          }\n          // Build only if pristine\n          $datepicker.$build(true);\n        };\n\n        $datepicker.updateDisabledDates = function (dateRanges) {\n          options.disabledDateRanges = dateRanges;\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\n          }\n        };\n\n        $datepicker.select = function (date, keep) {\n          // console.warn('$datepicker.select', date, scope.$mode);\n          if (angular.isDate(date)) {\n            if (!angular.isDate(controller.$dateValue) || isNaN(controller.$dateValue.getTime())) {\n              controller.$dateValue = new Date(date);\n            }\n          } else {\n            controller.$dateValue = null;\n          }\n          if (!scope.$mode || keep) {\n            controller.$setViewValue(angular.copy(date));\n            controller.$render();\n            if (options.autoclose && !keep) {\n              $timeout(function () { $datepicker.hide(true); });\n            }\n          } else {\n            angular.extend(viewDate, {year: date.getFullYear(), month: date.getMonth(), date: date.getDate()});\n            $datepicker.setMode(scope.$mode - 1);\n            $datepicker.$build();\n          }\n        };\n\n        $datepicker.setMode = function (mode) {\n          // console.warn('$datepicker.setMode', mode);\n          scope.$mode = mode;\n          $picker = $datepicker.$views[scope.$mode];\n          $datepicker.$build();\n        };\n\n        // Protected methods\n\n        $datepicker.$build = function (pristine) {\n          // console.warn('$datepicker.$build() viewDate=%o', viewDate);\n          if (pristine === true && $picker.built) return;\n          if (pristine === false && !$picker.built) return;\n          $picker.build.call($picker);\n        };\n\n        $datepicker.$updateSelected = function () {\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], updateSelected);\n          }\n        };\n\n        $datepicker.$isSelected = function (date) {\n          return $picker.isSelected(date);\n        };\n\n        $datepicker.$setDisabledEl = function (el) {\n          el.disabled = $picker.isDisabled(el.date);\n        };\n\n        $datepicker.$selectPane = function (value) {\n          var steps = $picker.steps;\n          // set targetDate to first day of month to avoid problems with\n          // date values rollover. This assumes the viewDate does not\n          // depend on the day of the month\n          var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\n          angular.extend(viewDate, {year: targetDate.getUTCFullYear(), month: targetDate.getUTCMonth(), date: targetDate.getUTCDate()});\n          $datepicker.$build();\n        };\n\n        $datepicker.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $datepicker.$onKeyDown = function (evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          if (evt.keyCode === 13) {\n            if (!scope.$mode) {\n              $datepicker.hide(true);\n            } else {\n              scope.$apply(function () { $datepicker.setMode(scope.$mode - 1); });\n            }\n            return;\n          }\n\n          // Navigate with keyboard\n          $picker.onKeyDown(evt);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function updateSelected (el) {\n          el.selected = $datepicker.$isSelected(el.date);\n        }\n\n        function focusElement () {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $datepicker.init;\n        $datepicker.init = function () {\n          if (isNative && options.useNative) {\n            element.prop('type', 'date');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if (isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $datepicker.destroy;\n        $datepicker.destroy = function () {\n          if (isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $datepicker.show;\n        $datepicker.show = function () {\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            // if $datepicker is no longer showing, don't setup events\n            if (!$datepicker.$isShown) return;\n            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n            if (options.keyboard) {\n              element.on('keydown', $datepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $datepicker.hide;\n        $datepicker.hide = function (blur) {\n          if (!$datepicker.$isShown) return;\n          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n          if (options.keyboard) {\n            element.off('keydown', $datepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $datepicker;\n\n      }\n\n      DatepickerFactory.defaults = defaults;\n      return DatepickerFactory;\n\n    };\n\n  })\n\n  .directive('bsDatepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\n\n    // var defaults = $datepicker.defaults;\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink (scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent', 'hasToday', 'hasClear'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'hasToday', 'hasClear'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // Initialize datepicker\n        var datepicker = $datepicker(element, controller, options);\n        options = datepicker.$options;\n        // Set expected iOS format\n        if (isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\n\n        var lang = options.lang;\n\n        var formatDate = function (date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!datepicker || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\n            if (newValue === true) {\n              datepicker.show();\n            } else {\n              datepicker.hide();\n            }\n          });\n        }\n\n        // Observe attributes for changes\n        angular.forEach(['minDate', 'maxDate'], function (key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          if (angular.isDefined(attr[key])) {\n            attr.$observe(key, function (newValue) {\n              // console.warn('attr.$observe(%s)=%o', key, newValue);\n              datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\n              // Build only if dirty\n              if (!isNaN(datepicker.$options[key])) datepicker.$build(false);\n              validateAgainstMinMaxDate(controller.$dateValue);\n            });\n          }\n        });\n\n        // Observe date format\n        if (angular.isDefined(attr.dateFormat)) {\n          attr.$observe('dateFormat', function (newValue) {\n            datepicker.$options.dateFormat = newValue;\n          });\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          datepicker.update(controller.$dateValue);\n        }, true);\n\n        // Normalize undefined/null/empty array,\n        // so that we don't treat changing from undefined->null as a change.\n        function normalizeDateRanges (ranges) {\n          if (!ranges || !ranges.length) return null;\n          return ranges;\n        }\n\n        if (angular.isDefined(attr.disabledDates)) {\n          scope.$watch(attr.disabledDates, function (disabledRanges, previousValue) {\n            disabledRanges = normalizeDateRanges(disabledRanges);\n            previousValue = normalizeDateRanges(previousValue);\n\n            if (disabledRanges) {\n              datepicker.updateDisabledDates(disabledRanges);\n            }\n          });\n        }\n\n        function validateAgainstMinMaxDate (parsedDate) {\n          if (!angular.isDate(parsedDate)) return;\n          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\n          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if (isValid) controller.$dateValue = parsedDate;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function (viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if (!viewValue) {\n            controller.$setValidity('date', true);\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            return null;\n          }\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\n            controller.$setValidity('date', false);\n            // return undefined, causes ngModelController to\n            // invalidate model value\n            return;\n          }\n          validateAgainstMinMaxDate(parsedDate);\n\n          if (options.dateType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if (options.dateType === 'number') {\n            return date.getTime();\n          } else if (options.dateType === 'unix') {\n            return date.getTime() / 1000;\n          } else if (options.dateType === 'iso') {\n            return date.toISOString();\n          }\n          return new Date(date);\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if (angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if (angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if (options.dateType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\n          } else if (options.dateType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if (isNaN(date.getTime())) {\n          //   var today = new Date();\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\n          // }\n          // do not adjust date if timezone is UTC\n          if (options.timezone === 'UTC') {\n            controller.$dateValue = date;\n          } else {\n            controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          }\n          return getDateFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function () {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getDateFormattedString());\n        };\n\n        function getDateFormattedString () {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (datepicker) datepicker.destroy();\n          options = null;\n          datepicker = null;\n        });\n\n      }\n    };\n\n  })\n\n  .provider('datepickerViews', function () {\n\n    // var defaults = this.defaults = {\n    //   dayFormat: 'dd',\n    //   daySplit: 7\n    // };\n\n    // Split array into smaller arrays\n    function split (arr, size) {\n      var arrays = [];\n      while (arr.length > 0) {\n        arrays.push(arr.splice(0, size));\n      }\n      return arrays;\n    }\n\n    // Modulus operator\n    function mod (n, m) {\n      return ((n % m) + m) % m;\n    }\n\n    this.$get = function ($dateFormatter, $dateParser, $sce) {\n\n      return function (picker) {\n\n        var scope = picker.$scope;\n        var options = picker.$options;\n\n        var lang = options.lang;\n        var formatDate = function (date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        var weekDaysMin = $dateFormatter.weekdaysShort(lang);\n        var weekDaysLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\n        var weekDaysLabelsHtml = $sce.trustAsHtml('<th class=\"dow text-center\">' + weekDaysLabels.join('</th><th class=\"dow text-center\">') + '</th>');\n\n        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\n        var viewDate = {year: startDate.getFullYear(), month: startDate.getMonth(), date: startDate.getDate()};\n\n        var views = [{\n          format: options.dayFormat,\n          split: 7,\n          steps: {month: 1},\n          update: function (date, force) {\n            if (!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getDate() !== viewDate.date || date.getDate() === 1) {\n                // chaging picker current month will cause viewDate.date to be set to first day of the month,\n                // in $datepicker.$selectPane, so picker would not update selected day display if\n                // user picks first day of the new month.\n                // As a workaround, we are always forcing update when picked date is first day of month.\n              viewDate.date = picker.$date.getDate();\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1);\n            var firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\n            var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5);\n            var firstDateOffset = firstDate.getTimezoneOffset();\n            var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\n              // Handle daylight time switch\n            if (firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\n            var days = [];\n            var day;\n            for (var i = 0; i < 42; i++) { // < 7 * 6\n              day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\n              days.push({date: day, isToday: day.toDateString() === today, label: formatDate(day, this.format), selected: picker.$date && this.isSelected(day), muted: day.getMonth() !== viewDate.month, disabled: this.isDisabled(day)});\n            }\n            scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\n            scope.showLabels = true;\n            scope.labels = weekDaysLabelsHtml;\n            scope.rows = split(days, this.split);\n            scope.isTodayDisabled = this.isDisabled(new Date());\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth() && date.getDate() === picker.$date.getDate();\n          },\n          isDisabled: function (date) {\n            var time = date.getTime();\n\n              // Disabled because of min/max date.\n            if (time < options.minDate || time > options.maxDate) return true;\n\n              // Disabled due to being a disabled day of the week\n            if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\n\n              // Disabled because of disabled date range.\n            if (options.disabledDateRanges) {\n              for (var i = 0; i < options.disabledDateRanges.length; i++) {\n                if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\n                  return true;\n                }\n              }\n            }\n\n            return false;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualTime = picker.$date.getTime();\n            var newDate;\n\n            if (evt.keyCode === 37) newDate = new Date(actualTime - 1 * 864e5);\n            else if (evt.keyCode === 38) newDate = new Date(actualTime - 7 * 864e5);\n            else if (evt.keyCode === 39) newDate = new Date(actualTime + 1 * 864e5);\n            else if (evt.keyCode === 40) newDate = new Date(actualTime + 7 * 864e5);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }, {\n          name: 'month',\n          format: options.monthFormat,\n          split: 4,\n          steps: {year: 1},\n          update: function (date, force) {\n            if (!this.built || date.getFullYear() !== viewDate.year) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getMonth() !== viewDate.month) {\n              angular.extend(viewDate, {month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            // var firstMonth = new Date(viewDate.year, 0, 1);\n            var months = [];\n            var month;\n            for (var i = 0; i < 12; i++) {\n              month = new Date(viewDate.year, i, 1);\n              months.push({date: month, label: formatDate(month, this.format), selected: picker.$isSelected(month), disabled: this.isDisabled(month)});\n            }\n            scope.title = formatDate(month, options.yearTitleFormat);\n            scope.showLabels = false;\n            scope.rows = split(months, this.split);\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\n          },\n          isDisabled: function (date) {\n            var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualMonth = picker.$date.getMonth();\n            var newDate = new Date(picker.$date);\n\n            if (evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\n            else if (evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\n            else if (evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\n            else if (evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }, {\n          name: 'year',\n          format: options.yearFormat,\n          split: 4,\n          steps: {year: 12},\n          update: function (date, force) {\n            if (!this.built || force || parseInt(date.getFullYear() / 20, 10) !== parseInt(viewDate.year / 20, 10)) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getFullYear() !== viewDate.year) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            var firstYear = viewDate.year - viewDate.year % (this.split * 3);\n            var years = [];\n            var year;\n            for (var i = 0; i < 12; i++) {\n              year = new Date(firstYear + i, 0, 1);\n              years.push({date: year, label: formatDate(year, this.format), selected: picker.$isSelected(year), disabled: this.isDisabled(year)});\n            }\n            scope.title = years[0].label + '-' + years[years.length - 1].label;\n            scope.showLabels = false;\n            scope.rows = split(years, this.split);\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear();\n          },\n          isDisabled: function (date) {\n            var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualYear = picker.$date.getFullYear();\n            var newDate = new Date(picker.$date);\n\n            if (evt.keyCode === 37) newDate.setYear(actualYear - 1);\n            else if (evt.keyCode === 38) newDate.setYear(actualYear - 4);\n            else if (evt.keyCode === 39) newDate.setYear(actualYear + 1);\n            else if (evt.keyCode === 40) newDate.setYear(actualYear + 4);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }];\n\n        return {\n          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\n          viewDate: viewDate\n        };\n\n      };\n\n    };\n\n  });\n","\nangular.module('mgcrea.ngStrap', [\n  'mgcrea.ngStrap.datepicker',\n  'mgcrea.ngStrap.timepicker',\n  'mgcrea.ngStrap.tooltip',\n]);\n"],"sourceRoot":"/source/"}